<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>58同城 房产字体 反爬</title>
    <url>/2020/12/25/58fangchanFont/</url>
    <content><![CDATA[<p>58同城 房产字体 反爬 </p>
<a id="more"></a>

<h3 id="58同城-房产字体-反爬"><a href="#58同城-房产字体-反爬" class="headerlink" title="58同城 房产字体 反爬"></a>58同城 房产字体 反爬</h3><ol>
<li><p>获取HTML </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url &#x3D; &quot;https:&#x2F;&#x2F;sz.58.com&#x2F;zufang&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">UA &#x3D; &#123;</span><br><span class="line">	&quot;referer&quot;: &quot;https:&#x2F;&#x2F;www.google.com&#x2F;&quot;,</span><br><span class="line">	&quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">html &#x3D; requests.get(url&#x3D;url, headers&#x3D;UA)</span><br><span class="line">html.encoding&#x3D;&quot;utf-8&quot;</span><br><span class="line"></span><br><span class="line">ret &#x3D; html.text</span><br><span class="line">with open(&#39;58-fangchan.txt&#39;, &quot;w&quot;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line">	f.write(ret)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>获取字体文件</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 1. 获取字体文件，</span><br><span class="line">with open(&quot;58-fangchan.txt&quot;, &quot;r&quot;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">	content &#x3D; f.read()</span><br><span class="line"></span><br><span class="line">font_face &#x3D; re.search(r&quot;base64,(.*?)&#39;\)&quot;, content).group(1)</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="3">
<li><p>转换 xml， 分析关系</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from fontTools.ttLib import TTFont</span><br><span class="line"></span><br><span class="line">font &#x3D; TTFont(&quot;.&#x2F;b-58fangchan字体.ttf&quot;)</span><br><span class="line">font.saveXML(&quot;b-58fangchan字体.xml&quot;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>字体的映射关系</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过，我们反复分析，得出数字取出 减1 </span><br></pre></td></tr></table></figure>
</li>
<li><p>全部代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import base64</span><br><span class="line">import io</span><br><span class="line">import re</span><br><span class="line">from lxml import etree</span><br><span class="line"></span><br><span class="line">from fontTools.ttLib import TTFont</span><br><span class="line"></span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># ret &#x3D; base64.b64decode(font_face)</span><br><span class="line"># with open(&#39;58fangchan.ttf&#39;, &#39;wb&#39;) as f:</span><br><span class="line"># 	f.write(ret)</span><br><span class="line"></span><br><span class="line"># font &#x3D; TTFont(ret)</span><br><span class="line"># font.saveXML(&#39;b-58.xml&#39;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url &#x3D; &quot;https:&#x2F;&#x2F;sz.58.com&#x2F;zufang&#x2F;&quot;</span><br><span class="line"></span><br><span class="line">UA &#x3D; &#123;</span><br><span class="line">	&quot;referer&quot;: &quot;https:&#x2F;&#x2F;www.google.com&#x2F;&quot;,</span><br><span class="line">	&quot;user-agent&quot;: &quot;Mozilla&#x2F;5.0 (Windows NT 10.0; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;86.0.4240.183 Safari&#x2F;537.36&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># html &#x3D; requests.get(url&#x3D;url, headers&#x3D;UA)</span><br><span class="line"># html.encoding&#x3D;&quot;utf-8&quot;</span><br><span class="line">#</span><br><span class="line"># ret &#x3D; html.text</span><br><span class="line"># with open(&#39;58-fangchan.txt&#39;, &quot;w&quot;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line"># 	f.write(ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 1. 获取字体文件，</span><br><span class="line">with open(&quot;58-fangchan.txt&quot;, &quot;r&quot;, encoding&#x3D;&#39;utf-8&#39;) as f:</span><br><span class="line">	content &#x3D; f.read()</span><br><span class="line"></span><br><span class="line">font_face &#x3D; re.search(r&quot;base64,(.*?)&#39;\)&quot;, content).group(1)</span><br><span class="line"># print(font_face)</span><br><span class="line"></span><br><span class="line"># 2. base64 解码</span><br><span class="line">ret &#x3D; base64.b64decode(font_face)</span><br><span class="line"></span><br><span class="line">font &#x3D; TTFont(io.BytesIO(ret))</span><br><span class="line"></span><br><span class="line">bestcmap &#x3D; font[&#39;cmap&#39;].getBestCmap()</span><br><span class="line"></span><br><span class="line">for k, v in bestcmap.items():</span><br><span class="line">	# print(k)</span><br><span class="line">	# print(v)</span><br><span class="line">	# k 此时 是10 进制 ，转成 16进制</span><br><span class="line">	k &#x3D; hex(k)</span><br><span class="line">	k &#x3D; k.replace(&#39;0x&#39;, &#39;&amp;#x&#39;) + &quot;;&quot;</span><br><span class="line">	# 通过，分析得出，取出v， -1 就对应数字</span><br><span class="line">	v &#x3D; int(re.search(r&#39;(\d+)&#39;, v).group(0)) -1</span><br><span class="line">	print(k)</span><br><span class="line">	print(v)</span><br><span class="line">	if k in content:</span><br><span class="line">		content &#x3D; content.replace(k, str(v))</span><br><span class="line">#</span><br><span class="line"># print(content)</span><br><span class="line"># # 3 .获取 标题 ，</span><br><span class="line">resp &#x3D; etree.HTML(content)</span><br><span class="line"></span><br><span class="line">lis &#x3D; resp.xpath(&quot;&#x2F;&#x2F;ul[@class&#x3D;&#39;listUl&#39;]&#x2F;li&quot;)</span><br><span class="line">for li in lis:</span><br><span class="line">    title &#x3D; li.xpath(&#39;.&#x2F;div[@class&#x3D;&quot;des&quot;]&#x2F;h2&#x2F;a&#x2F;text()&#39;)</span><br><span class="line">    if title:</span><br><span class="line">        title &#x3D; title[0]</span><br><span class="line">        print(title)</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>58同城 房产字体</tag>
        <tag>反爬</tag>
      </tags>
  </entry>
  <entry>
    <title>jobweb项目中所遇到知识点</title>
    <url>/2020/12/25/Jobwebproject%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p> jobweb项目中所遇到知识点</p>
<a id="more"></a>

<h3 id="jobweb项目中所遇到知识点"><a href="#jobweb项目中所遇到知识点" class="headerlink" title="jobweb项目中所遇到知识点"></a>jobweb项目中所遇到知识点</h3><ol>
<li><p>sqlalchemy . Customizing DDL</p>
<p>数据定义语言（DDL）。发出时，将调用预定的操作顺序，并无条件创建DDL以创建每个表，包括所有约束和与其关联的其他对象。对于需要特定于数据库的DDL的更复杂的方案，SQLAlchemy提供了两种技术，可用于根据任何条件添加任何DDL，包括表的标准生成或单独添加。 </p>
<p>官方文档—&gt;<a href="https://www.geek-book.com/src/docs/SQLAlchemy1.3/SQLAlchemy1.3/docs.sqlalchemy.org/en/13/core/ddl.html">文档</a></p>
</li>
<li><p>Flask扩展系列-用户会话管理</p>
<ul>
<li><p>Flask-Login  模块</p>
<ul>
<li><p>flask_login 是web开发框架flask的一个插件，可以非常方便的管理用户对网站的访问  </p>
</li>
<li><p>user 类 </p>
</li>
<li><pre><code class="Python">  # 安装 包
  pip3  install flask-login


</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<pre><code>        # 初始化 app
        from flask import Flask, render_template, redirect, request
        from flask_login import \
            (LoginManager,
             current_user,
             UserMixin,
             login_required,
             login_user,
             logout_user
             )

        app = Flask(__name__)
        app.config[&#39;SECRET_KEY&#39;] = &#39;ijaswe&#39;

        login_manager = LoginManager()
        login_manager.init_app(app)
        login_manager.login_view = &#39;/login&#39;
        login_manager.session_protection = &#39;strong&#39;   # 防止恶意用户篡改 cookies


        # user 类

        user_dict = &#123;&#125;

        class User(UserMixin):
            def load_by_user_id(self, user_id):
                &quot;&quot;&quot;
                在实际项目中，这个方法应该从数据库中根据user_id来查询用户信息
                为了演示方便，我这里省略了从数据库查询数据的过程
                如果数据库中没有user_id这个用户，你应该返回False
                :param user_id: 用户唯一标识
                :return: 
                &quot;&quot;&quot;
                self.user_id = 1
                self.username = user_dict.get(self.user_id)
                return True

            def get_id(self):
                return self.user_id
        <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    * login_required</span><br><span class="line"></span><br><span class="line">        *  &#96;@login_required&#96; 会做用户登录检测，如果没有登录要方法此视图函数，就被跳转到 &#96;login&#96; 接入点( &#96;endpoint&#96; ) </span><br><span class="line">        * &#96;current_user&#96; 是当前登录者，是 &#96;User&#96; 的实例，是 &#96;Flask-Login&#96; 提供全局变量（ 类似于全局变量 &#96;g&#96; ）</span><br><span class="line"></span><br><span class="line">    * 使用 Flask-WTF</span><br><span class="line"></span><br><span class="line">        * Flask表单：表单数据的验证与处理  </span><br><span class="line">        * 文档------》》》[flask表单](https:&#x2F;&#x2F;www.yiibai.com&#x2F;flask&#x2F;flask_wtf.html)</span><br><span class="line"></span><br><span class="line">    * Share()    基于jinja2模板创建社交共享组件 </span><br><span class="line"></span><br><span class="line">        * [文档](https:&#x2F;&#x2F;flask-share.readthedocs.io&#x2F;en&#x2F;latest&#x2F;)</span><br><span class="line"></span><br><span class="line">3. Faker 类</span><br><span class="line"></span><br><span class="line">     Python中有一个专门生成各类假数据的库：Faker </span><br><span class="line"></span><br><span class="line">     使用faker 构建测试数据库</span><br><span class="line"></span><br><span class="line">4. CKEditor(app)</span><br><span class="line"></span><br><span class="line">     是一个非常优秀的 Web 服文本编辑器，提供了非常多的功能和丰富的文档 </span><br><span class="line"></span><br><span class="line">5. Moment(app)</span><br><span class="line"></span><br><span class="line">     用于处理日期&#x2F;时间的 Python 库，设计灵感同样是来源于 [moment.js](https:&#x2F;&#x2F;www.oschina.net&#x2F;p&#x2F;moment-js) 和 [requests](https:&#x2F;&#x2F;www.oschina.net&#x2F;p&#x2F;requests)  </span><br><span class="line"></span><br><span class="line">6. get_or_404 方法</span><br><span class="line"></span><br><span class="line">     比如:meth: &#39; get &#39;，但如果没有找到，就会以404终止，而不是返回&#39; &#39; None &#39; &#39;。&quot; </span><br><span class="line"></span><br><span class="line">![1603206304293]( http:&#x2F;&#x2F;qny.jkraise.top&#x2F;project%E7%9F%A5%E8%AF%86%E7%82%B9.assets&#x2F;1603206304293.png~01style)</span><br><span class="line"></span><br><span class="line">7.   解决  mysql5.7.5之后sql_mode默认值是&quot;only_full_group_by&quot;，不能执行group_by查询 </span><br><span class="line"></span><br><span class="line">​	    mysql 中sql_mode 设置win 10 ， MYSQL8以上已经取消了 NO_AUTO_CREATE_USER，sql_mode中不能包含这      个。 </span><br><span class="line"></span><br><span class="line">​		在mysql.ini 中设置</span><br><span class="line"></span><br><span class="line">8. 用户类 UserMinxin 类， </span><br><span class="line"></span><br><span class="line">​	文档---&gt; [&#96;UserMixin&#96;](http:&#x2F;&#x2F;docs.jinkan.org&#x2F;docs&#x2F;flask-login&#x2F;#flask.ext.login.UserMixin)  </span><br><span class="line"></span><br><span class="line">9. form enctype 属性</span><br><span class="line"></span><br><span class="line">![1603242615042]( http:&#x2F;&#x2F;qny.jkraise.top&#x2F;project%E7%9F%A5%E8%AF%86%E7%82%B9.assets&#x2F;1603242615042.png~01style)</span><br><span class="line"></span><br><span class="line">10. csrf 保护</span><br><span class="line"></span><br><span class="line"> 	要对所有视图函数启用 CSRF 保护，你需要启用 [&#96;CsrfProtect&#96;](http:&#x2F;&#x2F;docs.jinkan.org&#x2F;docs&#x2F;flask-wtf&#x2F;api.html#flask_wtf.csrf.CsrfProtect) 模块: </span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre>
<p>from flask_wtf.csrf import CsrfProtect</p>
<p>CsrfProtect(app)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">11. @property 主要是让password字段无法直接读取</span><br><span class="line"></span><br><span class="line">​	@password.setter 修改用户的password 字段  (修改密码)</span><br><span class="line"></span><br><span class="line">12. UploadSet</span><br><span class="line"></span><br><span class="line">​	 flask可以实现上传文件和下载文件的基本功能，但如果想要健壮的功能，使用flask_uploads插件是十分方便的。 </span><br><span class="line"></span><br><span class="line"> 	UploadSet对象的主要方法是save,该方法必须传入werkzeug.FileStorage对象作为参数，然后检查文件名是否合法，将其转换；检查文件的扩展名是否允许，不允许抛出UploadNotAllowed()错误；调用resolve_conflict方法解决文件名冲突问题；然后将目录和文件名拼接成绝对路径保存在目录下，最后返回文件名； </span><br><span class="line"></span><br><span class="line">13. patch_request_class</span><br><span class="line"></span><br><span class="line">    * **限制文件大小**</span><br><span class="line"></span><br><span class="line">        导入patch_request_class()函数，传入应用实例和大小（默认为16MB），比如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>    patch_request_class(app, 32 * 1024 * 1024 ) 
    <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">14. Flask abort   函数</span><br><span class="line"></span><br><span class="line">    1. 用于提前退出 一个请求，并用指定的错误码 返回</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        &#96;&#96;&#96;python </span><br><span class="line">        flask.abort(status, *args, **kwargs) </span><br><span class="line">        abort(404)</span><br></pre></td></tr></table></figure></code></pre>
<h4 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h4><ol>
<li>用于响应式不局，移动设备优先的web 项目架构</li>
</ol>
]]></content>
      <categories>
        <category>web + flask</category>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>jobweb 项目 知识点</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/14/MeiDuoProjectExplain/</url>
    <content><![CDATA[<h3 id="网站首页广告分析（这里京东做分析）"><a href="#网站首页广告分析（这里京东做分析）" class="headerlink" title="网站首页广告分析（这里京东做分析）"></a>网站首页广告分析（这里京东做分析）</h3><h4 id="1-核心区"><a href="#1-核心区" class="headerlink" title="1.核心区"></a>1.核心区</h4><p><img src="MeiDuoProjectExplain.assets/1620994509496.png" alt="1620994509496"></p>
<h4 id="2-楼层"><a href="#2-楼层" class="headerlink" title="2.楼层"></a>2.楼层</h4><p><img src="MeiDuoProjectExplain.assets/1620994571806.png" alt="1620994571806"></p>
<p><img src="MeiDuoProjectExplain.assets/1620994592226.png" alt="1620994592226"></p>
<h3 id="SPU-和SKU"><a href="#SPU-和SKU" class="headerlink" title="SPU 和SKU"></a>SPU 和SKU</h3><ul>
<li>SPU 可以理解为一个类 ， 拥有相同属性， 相同方法， 比如 iPhone x   <ul>
<li>如手机-&gt;苹果手机-&gt;苹果6，苹果6就是SPU     </li>
</ul>
</li>
<li>SKU  可以理解为一个实例对象， 比如  iPhone x  全网通 黑色 256g  </li>
</ul>
<h3 id="Nginx部署静态"><a href="#Nginx部署静态" class="headerlink" title="Nginx部署静态"></a>Nginx部署静态</h3><ol>
<li><p><code>settings.py文件</code> 设置静态文件目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">STATIC_ROOT &#x3D; os.path.join(os.path.dirname(os.path.dirname(BAse_DIR)), &quot;front_end_pc&#x2F;static&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们要把静态文件收集到<code>front_end_pc/static</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py collectstatic</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h5 id="ubuntu-提前装好Nginx服务器"><a href="#ubuntu-提前装好Nginx服务器" class="headerlink" title="ubuntu 提前装好Nginx服务器"></a>ubuntu 提前装好Nginx服务器</h5><ul>
<li><p>1.配置Nginx服务器</p>
<p><strong>静态业务</strong></p>
</li>
</ul>
<p><img src="MeiDuoProjectExplain.assets/1623980357480.png" alt="1623980357480"></p>
<p><strong>动态业务</strong></p>
<p><img src="MeiDuoProjectExplain.assets/1623980721048.png" alt="1623980721048"></p>
<p><strong>server部分说明</strong></p>
<p><img src="MeiDuoProjectExplain.assets/1623982962155.png" alt="1623982962155"></p>
<p><strong>指定wsgi.py 启动配置文件为prod.py</strong></p>
<p><img src="MeiDuoProjectExplain.assets/1623986502245.png" alt="1623986502245"></p>
<p><strong>服务器地址</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keepalive_timeout  1000;</span><br><span class="line">upstream meiduo &#123;</span><br><span class="line">    server 1xx.1xx.27.77:8001;  # 此处为uwsgi运行的ip地址和端口号</span><br><span class="line">    # 如果有多台服务器，可以在此处继续添加服务器地址</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>uwsgi.ini</code>  放到  同<code>wsgi</code>同一路径下，做<code>uwsgi</code>服务器配置</p>
<p><strong>uwsgi.ini</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line">#使用nginx连接时使用，Django程序所在服务器地址</span><br><span class="line">socket&#x3D;192.168.x.xx:8001</span><br><span class="line">#直接做web服务器使用，Django程序所在服务器地址</span><br><span class="line"># http&#x3D;1xx.168.xxx.133:8001</span><br><span class="line">#项目目录</span><br><span class="line">chdir&#x3D;&#x2F;Users&#x2F;chao&#x2F;Desktop&#x2F;meiduo&#x2F;meiduo_mall</span><br><span class="line">#项目中wsgi.py文件的目录，相对于项目目录</span><br><span class="line">wsgi-file&#x3D;meiduo_mall&#x2F;wsgi.py</span><br><span class="line"># 进程数</span><br><span class="line">processes&#x3D;4</span><br><span class="line"># 线程数</span><br><span class="line">threads&#x3D;2</span><br><span class="line"># uwsgi服务器的角色   # True 为主，False 为从</span><br><span class="line">master&#x3D;True    </span><br><span class="line"># 存放进程编号的文件</span><br><span class="line">pidfile&#x3D;uwsgi.pid</span><br><span class="line"># 日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的</span><br><span class="line">daemonize&#x3D;uwsgi.log</span><br><span class="line"># 指定依赖的虚拟环境</span><br><span class="line">virtualenv&#x3D;&#x2F;Users&#x2F;chao&#x2F;.virtualenvs&#x2F;django_20</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<p><img src="MeiDuoProjectExplain.assets/1624165971359.png" alt="1624165971359"></p>
<p><strong>uwsgi 命令</strong></p>
<ul>
<li><p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --ini uwsgi.ini</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uwsgi --stop uwsgi.ini</span><br><span class="line"># 或者 kill</span><br></pre></td></tr></table></figure>













</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/15/Python%E5%8D%95%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="Python-单例方法"><a href="#Python-单例方法" class="headerlink" title="Python 单例方法"></a>Python 单例方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式1  创建单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> cls._instance:</span><br><span class="line">            cls._instance = super().__new__(cls, *args, **kwargs)</span><br><span class="line">            </span><br><span class="line">     	<span class="keyword">return</span> cls._instance</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goto</span>(<span class="params">self,</span>):</span></span><br><span class="line">        print(<span class="string">&quot;cj&gt;&gt;&gt;&gt;&gt;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line">print(id(a))  <span class="comment">#2641366741704</span></span><br><span class="line">b = A()</span><br><span class="line">print(id(b))  <span class="comment">#2641366741704</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 方式2  创建单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls, *args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(A, <span class="string">&quot;_instance&quot;</span>):  <span class="comment"># 是否有_instance属性</span></span><br><span class="line">            cls._instance = super().__new__(cls, *args, **kwargs)</span><br><span class="line">            </span><br><span class="line">     	<span class="keyword">return</span> cls._instance</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goto</span>(<span class="params">self,</span>):</span></span><br><span class="line">        print(<span class="string">&quot;cj&gt;&gt;&gt;&gt;&gt;&quot;</span>)            </span><br></pre></td></tr></table></figure>

<h3 id="使用单例-控制-只有一个短信发送对象"><a href="#使用单例-控制-只有一个短信发送对象" class="headerlink" title="使用单例 控制 只有一个短信发送对象"></a>使用单例 控制 只有一个短信发送对象</h3><p>内存优化，减少内存消耗</p>
<h3 id="使用pipline-操作redis"><a href="#使用pipline-操作redis" class="headerlink" title="使用pipline 操作redis"></a>使用pipline 操作redis</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pl &#x3D; redis.cli.pipeline()</span><br><span class="line">pl.setex(&quot;send_flag_%s&quot; % mobile, 60, 1)</span><br><span class="line">pl.setex(&quot;sms_%s&quot; % mobile, 300, sms_code)</span><br><span class="line"></span><br><span class="line"># 5. 保存短信验证码到redis</span><br><span class="line"># redis_cli.setex()</span><br><span class="line"># 执行请求</span><br><span class="line">pl.execute()	#一次执行，减少内存消耗</span><br></pre></td></tr></table></figure>

<h3 id="异步方案-celery-发短信"><a href="#异步方案-celery-发短信" class="headerlink" title="异步方案 celery 发短信"></a>异步方案 celery 发短信</h3><p><strong>生产消费者模式</strong></p>
<ul>
<li><p>安装celery创建sms 包，并添加异步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -U celery</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>在根目录下 创建celery的包 </p>
<p><img src="Python%E5%8D%95%E4%BE%8B.assets/1618539278351.png" alt="1618539278351"></p>
</li>
<li><p>main.py</p>
<ul>
<li>1 设置django环境<br>2 创建celery对象<br>3 设置 broker<br>4 celery自动检测任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"># 1 设置django环境</span><br><span class="line"># set the default Django settings module for the &#39;celery&#39; program.</span><br><span class="line">from celery import Celery</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(&#39;DJANGO_SETTINGS_MODULE&#39;, &#39;meiduo.settings&#39;)</span><br><span class="line"></span><br><span class="line"># 2 创建celery对象</span><br><span class="line">app &#x3D; Celery(&#39;celery_tasks&#39;)</span><br><span class="line"></span><br><span class="line"># 3 设置 broker</span><br><span class="line">app.config_from_object(&quot;celery_tasks.config&quot;)</span><br><span class="line"></span><br><span class="line"># 4celery自动检测任务  这里会自动去celery_tasks.sms下找tasks.py</span><br><span class="line">app.autodiscover_tasks([&#39;celery_tasks.sms&#39;])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>redis 作为队列  </p>
<ul>
<li>config.py </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 把redis 作为队列</span><br><span class="line">broker_url &#x3D; &quot;redis:&#x2F;&#x2F;127.0.0.1&#x2F;15&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>sms的tasks.py里添加任务</p>
<ul>
<li>tasks.py文件名不可改变</li>
</ul>
<p><img src="Python%E5%8D%95%E4%BE%8B.assets/1618539600277.png" alt="1618539600277"></p>
</li>
</ul>
<h4 id="启动celery"><a href="#启动celery" class="headerlink" title="启动celery"></a>启动celery</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line">celery -A celery_tasks.main worker -l info</span><br></pre></td></tr></table></figure>

<p><img src="Python%E5%8D%95%E4%BE%8B.assets/1618540420762.png" alt="1618540420762"></p>
<h4 id="win10-遇到的小bug"><a href="#win10-遇到的小bug" class="headerlink" title="win10 遇到的小bug"></a>win10 遇到的小bug</h4><p>开启服务发现，任务并未执行  上网查资料后发现，celery 对win10  支持并不是很好</p>
<p>解决此方案的</p>
<ul>
<li><p>方案1</p>
</li>
<li><p>添加–pool=solo参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">celery -A celery_tasks.main worker --pool&#x3D;solo -l info</span><br></pre></td></tr></table></figure>
</li>
<li><p>方案2</p>
</li>
<li><p>先安装gevent，然后在启动celery的时候添加gevent参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install gevent</span><br><span class="line">celery -A celery_tasks.main worker -l info -P gevent</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参考资料：<a href="https://stackoverflow.com/questions/37255548/how-to-run-celery-on-windows">https://stackoverflow.com/questions/37255548/how-to-run-celery-on-windows</a></p>
<h3 id="Django-地址设计"><a href="#Django-地址设计" class="headerlink" title="Django 地址设计"></a>Django 地址设计</h3><h4 id="省市区三级联动"><a href="#省市区三级联动" class="headerlink" title="省市区三级联动"></a>省市区三级联动</h4><ul>
<li><h5 id="缓存省市区数据"><a href="#缓存省市区数据" class="headerlink" title="缓存省市区数据"></a>缓存省市区数据</h5><blockquote>
<p>提示：</p>
</blockquote>
<ul>
<li>省市区数据是我们动态查询的结果。</li>
<li>但是省市区数据不是频繁变化的数据，所以没有必要每次都重新查询。</li>
<li>所以我们可以选择对省市区数据进行缓存处理。</li>
</ul>
</li>
<li><p>缓存方式</p>
<ul>
<li><code>from django.core.cache import cache</code></li>
<li>存储缓存数据：<code>cache.set(&#39;key&#39;, 内容, 有效期)</code></li>
<li>读取缓存数据：<code>cache.get(&#39;key&#39;)</code></li>
<li>删除缓存数据：<code>cache.delete(&#39;key&#39;)</code></li>
<li><strong>注意：存储进去和读取出来的数据类型相同，所以读取出来后可以直接使用。</strong></li>
</ul>
</li>
<li><p><strong>缓存逻辑实现</strong></p>
<ul>
<li>省份缓存数据<ul>
<li><code>cache.set(&#39;province_list&#39;, province_list, 3600)</code></li>
</ul>
</li>
<li>市或区缓存数据<ul>
<li><code>cache.set(&#39;sub_area_&#39; + area_id, sub_data, 3600)</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="省级三联orm"><a href="#省级三联orm" class="headerlink" title="省级三联orm"></a>省级三联orm</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查询所有省份</span><br><span class="line">select * from tb_areas where parent_id is Null;</span><br><span class="line"></span><br><span class="line">area_list &#x3D; Area.objects.filter(parent&#x3D;None)</span><br><span class="line">Area.objects.filter(parent__isnull &#x3D; True)</span><br></pre></td></tr></table></figure>

<p>查询市级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select * from tb_areas where parent_id&#x3D;130000; # 市</span><br><span class="line">Area.objects.filter(parent_id &#x3D; 130000)</span><br><span class="line"></span><br><span class="line">area_hebei &#x3D; Area.objects.get(id &#x3D; 130000) 河北省</span><br><span class="line">area_hebei.subs.all() 河北省所有的市</span><br><span class="line"></span><br><span class="line">select * from tb_areas where parent_id&#x3D;130200; #  区县</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Ubuntu18.04 从零搭建(python开发环境)</title>
    <url>/2021/04/11/Ubuntu18.04%E4%BB%8E0%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<pre><code>1. install  Python 3.8
 2. install  virtualenv  &amp; virtualenvwrapper
 3. install   MySQL
 4. install   Redis
 5. install    MongoDB
 6. install    Pycharm</code></pre>
<a id="more"></a>
<h2 id="Ubuntu18-04-从零搭建-python开发环境"><a href="#Ubuntu18-04-从零搭建-python开发环境" class="headerlink" title="Ubuntu18.04 从零搭建(python开发环境)"></a>Ubuntu18.04 从零搭建(python开发环境)</h2><h3 id="环境说明："><a href="#环境说明：" class="headerlink" title="环境说明："></a>环境说明：</h3><pre><code> 1. install  Python 3.8
 2. install  virtualenv  &amp; virtualenvwrapper
 3. install   MySQL
 4. install   Redis
 5. install    MongoDB
 6. install    Pycharm</code></pre>
<h3 id="1-修改-apt源-加快安装速度"><a href="#1-修改-apt源-加快安装速度" class="headerlink" title="1.修改 apt源( 加快安装速度)"></a>1.修改 apt源( 加快安装速度)</h3><ol>
<li><p>复制源文件备份， 以防万一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</span><br></pre></td></tr></table></figure>
</li>
<li><p>编辑源文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br></pre></td></tr></table></figure>

<p>在文件的最前面 添加阿里云镜像源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#  阿里源</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
</li>
<li><p>刷新列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line">sudo apt-get install build-essential</span><br></pre></td></tr></table></figure>

<p><a href="https://zhuanlan.zhihu.com/p/61228593">详情请到此篇知乎 </a></p>
</li>
</ol>
<h3 id="1-1-修改pip源"><a href="#1-1-修改pip源" class="headerlink" title="1.1 修改pip源"></a>1.1 修改pip源</h3><p>常用的国内源<br>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣 <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科技大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a><br>————————————————<br>版权声明：本文为CSDN博主「qyhaill」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qyhaill/article/details/98472936">https://blog.csdn.net/qyhaill/article/details/98472936</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 临时使用</span><br><span class="line">	pip install scrapy -i  http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 永久修改</span><br><span class="line">  <span class="number">2.1</span> 创建 ~/.pip/pip.conf</span><br><span class="line">  <span class="number">2.2</span>  将下面 内容添加进去</span><br><span class="line">[<span class="keyword">global</span>]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-install-Python3-8"><a href="#2-install-Python3-8" class="headerlink" title="2.install Python3.8"></a>2.install Python3.8</h3><p>参照，搬过来<a href="https://ywnz.com/linux/6041.html">云网牛站—-Python3.8 安装</a></p>
<p><strong>a.  从Deadsnakes PPA 安装deb软件包</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install software-properties-common</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> 将Deadsnakes PPA添加到系统的来源列表中：</span><br><span class="line">sudo add-apt-repository ppa:deadsnakes/ppa</span><br><span class="line">    </span><br><span class="line">出现提示时，按Enter继续：</span><br><span class="line">Press [ENTER] to <span class="keyword">continue</span> <span class="keyword">or</span> Ctrl-c to cancel adding it.</span><br><span class="line">注：意思是按[ENTER]继续，或按Ctrl-c取消添加。</span><br><span class="line">    </span><br><span class="line">sudo apt install python3<span class="number">.8</span>  </span><br><span class="line">python3<span class="number">.8</span> -V</span><br><span class="line"></span><br><span class="line">返回信息：</span><br><span class="line">Python <span class="number">3.8</span><span class="number">.0</span></span><br><span class="line">至此，Python <span class="number">3.8</span>已安装在Ubuntu <span class="number">18.04</span>系统上，你可以开始使用它了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**b.  从源代码在Ubuntu 18.04上安装Python 3.8 **</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>、更新软件包列表并安装构建Python所需的软件包：</span><br><span class="line">sudo apt update</span><br><span class="line"></span><br><span class="line">sudo apt install build-essential zlib1g-dev libncurses5-dev libgdbm-dev libnss3-dev libssl-dev libreadline-dev libffi-dev wget</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、使用wget从Python下载页面下载最新版本的源代码，或者访问 https://www.python.org/ 网站下载：</span><br><span class="line">wget https://www.python.org/ftp/python/<span class="number">3.8</span><span class="number">.0</span>/Python<span class="number">-3.8</span><span class="number">.0</span>.tgz</span><br><span class="line">   </span><br><span class="line"><span class="number">3.</span> 解压压缩文件</span><br><span class="line">tar -xf Python<span class="number">-3.8</span><span class="number">.0</span>.tgz  </span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 切换到Python原目录并执行 configure脚本， </span><br><span class="line">cd Python<span class="number">-3.8</span><span class="number">.0</span></span><br><span class="line">./configure --enable-optimizations</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 启动构建Python3<span class="number">.8</span></span><br><span class="line">make -j <span class="number">8</span></span><br><span class="line">为了加快构建时间，请修改-j以使其对应于处理器中的内核数，你可以通过键入nproc查找编号。</span><br><span class="line"></span><br><span class="line"><span class="number">6.</span> 构建过程完成后，输入一下命令安装Python二进制文件</span><br><span class="line">sudo make altinstall</span><br><span class="line"></span><br><span class="line"><span class="number">7.</span> 验证</span><br><span class="line">python3<span class="number">.8</span> -V</span><br><span class="line">输出应显示Python版本：</span><br><span class="line">Python <span class="number">3.8</span><span class="number">.0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-安装并配置virtualenv-和virtualenvwrapper"><a href="#3-安装并配置virtualenv-和virtualenvwrapper" class="headerlink" title="3.安装并配置virtualenv 和virtualenvwrapper"></a>3.安装并配置virtualenv 和virtualenvwrapper</h3><ol>
<li><p>安装并配置virtualenv 和virtualenvwrapper</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install virtualenv</span><br><span class="line">pip install virtualenvwrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建文件夹</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkdir $HOME/.virtualenvs</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>在~/.bashrc中加入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">export WORKON_HOME=$HOME/.virtualenvs</span><br><span class="line">export VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line">source /usr/local/bin/virtualenvwrapper.sh</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中virtualenvwrapper.sh的位置视情况而定，可能在<code>\usr\local\bin</code>中，也可能在<code>~/.local/bin</code>中。 </p>
</li>
<li><p>激活. bashrc文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">source .bashrc</span><br></pre></td></tr></table></figure>

<p>注： 如果出现 ERROR: virtualenvwrapper could not find virtualenv in your path, 可以在<del>/.bashrc中加入PATH=$PATH:</del>/.local/bin 或者 PATH=$PATH:/usr/local/bin。<br>————————————————<br>版权声明：本文为CSDN博主「qyhaill」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qyhaill/article/details/98472936">https://blog.csdn.net/qyhaill/article/details/98472936</a></p>
</li>
</ol>
<p>​      <a href="https://blog.csdn.net/qyhaill/article/details/98472936">virtualenv常用命令</a></p>
<h4 id="一些个人遇到问题-❤❤❤❤感谢以下博主❤❤❤❤❤"><a href="#一些个人遇到问题-❤❤❤❤感谢以下博主❤❤❤❤❤" class="headerlink" title="一些个人遇到问题(❤❤❤❤感谢以下博主❤❤❤❤❤)"></a>一些个人遇到问题(❤❤❤❤感谢以下博主❤❤❤❤❤)</h4><p><a href="https://blog.csdn.net/u011092188/article/details/64123561">pip安装软件时出现Command “python setup.py egg_info” failed with error code 1 in /tmp/pip-build*的解决方案</a></p>
]]></content>
      <categories>
        <category>Ubuntu18.04</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu18.04</tag>
        <tag>python 开发</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>c++教程</title>
    <url>/2021/04/11/c++001/</url>
    <content><![CDATA[<p>c++教程</p>
<a id="more"></a>]]></content>
      <categories>
        <category>c++</category>
        <category>c</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c++ 入门</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/23/docker02/</url>
    <content><![CDATA[<h4 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h4><ol>
<li>下载一个基本的镜像<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure></li>
<li>创建一个容器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it  ubuntu:16.04</span><br></pre></td></tr></table></figure></li>
<li>需求是 安装vi<br>需要 修改 /etc/apt/sources.list   更新源</li>
</ol>
<p>3.1 编辑一个sources.list 复制到docker 容器中<br>docker cp sources.list  容器id:/home   将sources.list 复制到容器中<br>3.2 在容器中将/home/ 下的sources.list 替换   /etc/apt/sources.list </p>
<p>3.3 让更新源生效 apt update<br>3.4  安装vi apt install vim</p>
<ol start="4">
<li><p>将容器打包为镜像<br>docker commit -m “备注” 容器的id  镜像的名字：版本</p>
</li>
<li><p>上传</p>
</li>
<li><p>1 在hub.docker.com 注册&amp;登录</p>
</li>
<li><p>2 在终端docker login 登录</p>
</li>
<li><p>3 通过tag 打标签<br>  docker tag 镜像名:版本  用户名/镜像名:版本</p>
</li>
<li><p>4 推送到仓库<br>  docker push 用户名/镜像名:版本</p>
</li>
</ol>
<p> <strong>检查镜像的信息</strong><br> docker inspect 镜像的名字：版本</p>
<h4 id="方式二-Dockerfile"><a href="#方式二-Dockerfile" class="headerlink" title="方式二 Dockerfile"></a>方式二 Dockerfile</h4><ol>
<li>新创一个文件夹， 新创一个Dockerfile 文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir my_nginx </span><br><span class="line">$ cd my_nginx </span><br><span class="line">$ touch Dockerfile</span><br></pre></td></tr></table></figure></li>
<li>编写文件Dockerfile<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 检查 是否有 这个镜像， 没有则会下载</span><br><span class="line">FROM nginx:1.0</span><br><span class="line"># run 运行命令 shell </span><br><span class="line">RUN echo &#39;&lt;h1&gt; hello Docker&lt;&#x2F;h1&gt;&#39; &gt; &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html</span><br></pre></td></tr></table></figure></li>
<li>构建新镜象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t 镜像名字:版本 上下文路径</span><br><span class="line"></span><br><span class="line">docker build -t my_nginx:1.0 .</span><br></pre></td></tr></table></figure></li>
<li>运行容器<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm -p 8002:80 mynginx:1.0</span><br></pre></td></tr></table></figure>


</li>
</ol>
<h3 id="镜像进阶-版"><a href="#镜像进阶-版" class="headerlink" title="镜像进阶 版"></a>镜像进阶 版</h3><h5 id="一个特殊镜像-scratch-这个镜像是虚拟的概念，-并不实际存在"><a href="#一个特殊镜像-scratch-这个镜像是虚拟的概念，-并不实际存在" class="headerlink" title="一个特殊镜像 scratch 这个镜像是虚拟的概念， 并不实际存在"></a>一个特殊镜像 <code>scratch</code> 这个镜像是虚拟的概念， 并不实际存在</h5><p>它表示一个空白的镜像<br>使用’Go ‘语言 开发 常用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM scratch</span><br></pre></td></tr></table></figure>
<p>RUN XXXXX<br>每次run 就是一层</p>
<p>Union FS 是有最大层数限制的，比如 AUFS，曾经是最大不得超过 42 层，现在是不得超过 127 层。</p>
<p><strong>注意</strong><br>一般 Dockerfile 放于一个空目录下， 或者项目根目录下。<br>如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。 </p>
<p>-f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。</p>
<p>docker build 支持 url </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t hello-world https:&#x2F;&#x2F;github.com&#x2F;docker-library&#x2F;hello-world.git#master:amd64&#x2F;hello-world</span><br></pre></td></tr></table></figure>

<p>这行命令指定了构建所需的 Git repo，并且指定分支为 master，构建目录为 /amd64/hello-world/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建。</p>
<p><strong>ADD 更高级的复制文件</strong></p>
<p>在 Docker 官方的 Dockerfile <a href="https://yeasy.gitbook.io/docker_practice/appendix/best_practices">最佳实践文档</a> 中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。另外需要注意的是，ADD 指令会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。因此在 COPY 和 ADD 指令中选择的时候，可以遵循这样的原则，所有的文件复制均使用 COPY 指令，仅在需要自动解压缩的场合使用 ADD。在使用该指令的时候还可以加上 –chown=<user>:<group> 选项来改变文件的所属用户及所属组。</p>
<p><strong>CMD</strong><br>格式：CMD [“可执行文件”, “参数1”, “参数2”…]</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/23/docker/</url>
    <content><![CDATA[<h3 id="镜像images"><a href="#镜像images" class="headerlink" title="镜像images"></a>镜像images</h3><ol>
<li>获取镜像<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dock pull [选项] [Docker Registry 地址[:端口号]&#x2F;]仓库名[:标签]</span><br></pre></td></tr></table></figure></li>
<li>运行<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ docker run -it --rm ubuntu:18.04 bash</span><br><span class="line">root@e7009c6ce357:&#x2F;# cat &#x2F;etc&#x2F;os-release</span><br><span class="line">NAME&#x3D;&quot;Ubuntu&quot;</span><br><span class="line">VERSION&#x3D;&quot;18.04.1 LTS (Bionic Beaver)&quot;</span><br><span class="line">ID&#x3D;ubuntu</span><br><span class="line">ID_LIKE&#x3D;debian</span><br><span class="line">PRETTY_NAME&#x3D;&quot;Ubuntu 18.04.1 LTS&quot;</span><br><span class="line">VERSION_ID&#x3D;&quot;18.04&quot;</span><br><span class="line">HOME_URL&#x3D;&quot;https:&#x2F;&#x2F;www.ubuntu.com&#x2F;&quot;</span><br><span class="line">SUPPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;help.ubuntu.com&#x2F;&quot;</span><br><span class="line">BUG_REPORT_URL&#x3D;&quot;https:&#x2F;&#x2F;bugs.launchpad.net&#x2F;ubuntu&#x2F;&quot;</span><br><span class="line">PRIVACY_POLICY_URL&#x3D;&quot;https:&#x2F;&#x2F;www.ubuntu.com&#x2F;legal&#x2F;terms-and-policies&#x2F;privacy-policy&quot;</span><br><span class="line">VERSION_CODENAME&#x3D;bionic</span><br><span class="line">UBUNTU_CODENAME&#x3D;bionic</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>docker run 就是运行容器的命令</strong></p>
<ul>
<li><code>-it</code> ：这是两个参数， 一个是<code>-i</code>  交互式操作，一个是’-t’ 终端，我们这里打算 进入<code>bash</code> 执行一些命令并</li>
<li>–rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 –rm 可以避免浪费空间</li>
<li>ubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。</li>
<li>bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash</li>
<li>exit 退出了这个容器</li>
</ul>
<h5 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="docker.assets/642_1.png"></p>
<h5 id="挂载硬盘"><a href="#挂载硬盘" class="headerlink" title="挂载硬盘"></a>挂载硬盘</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run ... -v 主机目录:容器中的目录 ...</span><br></pre></td></tr></table></figure>
<h5 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker cp 源目录 目标目录</span><br></pre></td></tr></table></figure>

<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images -----&gt; 查看已下载的镜像</span><br><span class="line">docker rmi 镜像名称:标签名      -----&gt; 删除已下载镜像</span><br><span class="line">docker search 镜像   -----&gt;   从官方仓库（hub.docker.com）查找镜像</span><br><span class="line">docker pull 镜像名称:标签名   -----&gt; 标签名默认是 latest，代表最新版本。</span><br><span class="line">docker pull 镜像名 ------&gt;下载最新版</span><br><span class="line">docker ps      -----&gt;  列出运行中的容器（运行中）</span><br><span class="line">docker ps -a  ------&gt; 列出所有的容器（运行、未运行）</span><br><span class="line">docker ps -a 查看所有的容器</span><br><span class="line">CONTAINER ID   IMAGE        COMMAND     CREATED         STATUS         PORTS     NAMES</span><br><span class="line">7c291fb47b70   python:3.9   &quot;python3&quot;   4 minutes ago   Up 4 minutes             priceless_almeida</span><br><span class="line">docker stop 容器名称id  -----&gt;  停止容器</span><br><span class="line">docker start 容器名称id   -----&gt;  启动容器</span><br><span class="line">docker start -i 容器的id  ---&gt;在将一个停止的容器运行起来的同时，指定交互模式</span><br><span class="line">docker restart 容器名称id  -----&gt;  重启容器</span><br><span class="line">docker rm 容器id   -----&gt; 删除 已经停止运行的容器</span><br><span class="line">docker rm $(docker ps -a -q)    -----&gt; 删除所有停止运行的容器 （慎用）</span><br><span class="line">docker rm -f 容器的id  -----&gt; 强制删除容器 （无论是否停止运行）</span><br><span class="line">docker rmi  镜像的id</span><br><span class="line">docker run 镜像名字:版本  -----&gt;创建一个容器且运行</span><br><span class="line">                -it ---&gt;交互模式</span><br><span class="line">docker exec  执行容器中的指令</span><br></pre></td></tr></table></figure>
<p><strong>Dockerfile 参数</strong></p>
<p>FROM：指定基础镜像，必须为第一个命令<br>MAINTAINER: 维护者信息<br>ENV：设置环境变量<br>RUN：构建镜像时执行的命令<br>ADD：将本地文件添加到容器中，tar类型文件会自动解压(网络压缩资源不会被解压)，可以访问网络资源，类似wget<br>EXPOSE：指定于外界交互的端口<br>VOLUME：用于指定持久化目录<br>WORKDIR：工作目录，类似于cd命令<br><img src="docker.assets/643_1.png"></p>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>使用MySQL镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d --name&#x3D;mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;123456 mysql:5.5</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li>–name=mysql：为容器指定一个名称为mysql</li>
<li>-p 3306:3306：将容器的（后面的3306） 3306 端口映射到主机的（前面的3306） 3306端口。</li>
<li>-d：后台运行容器，并返回容器ID。</li>
<li>-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码为123456。</li>
<li>mysql:5.5 要使用的镜像的名称</li>
</ul>
<h4 id="网络-指令"><a href="#网络-指令" class="headerlink" title="网络 指令"></a>网络 指令</h4><p><strong>查看 网络列表</strong><br><code>docker network ls</code><br><img src="docker.assets/645_1.png"></p>
<p><strong>当我们在使用docker-compose构建服务时，会自动创建一个新的网络如下</strong><br><strong>查看这个网络中所有的容器ip以及其他信息</strong><br><code>docker network inspect 网络id</code><br><img src="docker.assets/644_1.png"></p>
<p><strong>新建一个网络</strong><br><code>$ docker network create -d bridge my-net</code></p>
<p><strong>运行容器连接到my-net 网络</strong><br><code>docker run --rm -it --network my-net my_flask:1.0 bash</code></p>
]]></content>
  </entry>
  <entry>
    <title>git-命令</title>
    <url>/2020/10/09/git-%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>Git 基础 命令</p>
<a id="more"></a>



<h3 id="Git-基础-命令"><a href="#Git-基础-命令" class="headerlink" title="Git 基础 命令"></a>Git 基础 命令</h3><h5 id="一-git-仓库"><a href="#一-git-仓库" class="headerlink" title="一. git 仓库"></a>一. git 仓库</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">git init xxx <span class="comment"># 初始化仓库xxx</span></span><br><span class="line"></span><br><span class="line">git clone 	 <span class="comment"># git克隆 + 远程仓库地址</span></span><br><span class="line"></span><br><span class="line">git remote -v <span class="comment"># 查看远程地址 fetch  push</span></span><br><span class="line">origin  https://github.com/joinik/xinjingzixun_2020 (fetch)</span><br><span class="line">origin  https://github.com/joinik/xinjingzixun_2020 (push)</span><br><span class="line">========</span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">git remote remove origin  <span class="comment"># </span></span><br><span class="line">$ git remote -v       	<span class="comment"># 查看远程仓库：</span></span><br><span class="line">$ git remote add [name] [url]	<span class="comment">#添加远程仓库：</span></span><br><span class="line">$ git remote rm [name]	<span class="comment">#删除远程仓库：</span></span><br><span class="line">$ git remote set-url --push [name] [newUrl]		<span class="comment">#修改远程仓库：</span></span><br><span class="line">$ git pull [remoteName] [localBranchName]	<span class="comment">#拉取远程仓库：</span></span><br><span class="line">$ git push [remoteName] [localBranchName]	<span class="comment">#推送远程仓库：</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支（branch）</span></span><br><span class="line">git branch 	<span class="comment">#查看本地分支</span></span><br><span class="line">git branch -r <span class="comment"># 查看远程分支</span></span><br><span class="line">git branch [name] -- 注意新分支创建后， 不会切换到新分支</span><br><span class="line">git branch -a <span class="comment"># 查看本地，远程所有分支</span></span><br><span class="line">git checkout [name] <span class="comment"># 切换分支</span></span><br><span class="line">git checkout -b [name] <span class="comment"># 创建并切换到新分支</span></span><br><span class="line">git branch -d <span class="comment"># 删除分支  选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="二-配置"><a href="#二-配置" class="headerlink" title="二. 配置"></a>二. 配置</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--<span class="keyword">global</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--<span class="keyword">global</span>] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--<span class="keyword">global</span>] user.email <span class="string">&quot;[email address]&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="三，增加、删除文件"><a href="#三，增加、删除文件" class="headerlink" title="三，增加、删除文件"></a>三，增加、删除文件</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 查看当前 文件变化</span><br><span class="line">git status -s</span><br><span class="line"></span><br><span class="line"># 添加指定文件到暂存区</span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 添加指定目录到暂存区，包括子目录</span><br><span class="line">$ git add [dir]</span><br><span class="line"></span><br><span class="line"># 添加当前目录的所有文件到暂存区</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"># 添加每个变化前，都会要求确认</span><br><span class="line"># 对于同一个文件的多处变化，可以实现分次提交</span><br><span class="line">$ git add -p</span><br><span class="line"></span><br><span class="line"># 删除工作区文件，并且将这次删除放入暂存区</span><br><span class="line">$ git rm [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"># 停止追踪指定文件，但该文件会保留在工作区</span><br><span class="line">$ git rm --cached [file]</span><br><span class="line"></span><br><span class="line"># 改名文件，并且将这个改名放入暂存区</span><br><span class="line">$ git mv [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h5 id="四，代码提交"><a href="#四，代码提交" class="headerlink" title="四，代码提交"></a>四，代码提交</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 附注标签</span><br><span class="line">$ git tag -a v1.4 -m &quot;my version 1.4&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 提交暂存区到仓库区</span><br><span class="line">$ git commit -m [message]</span><br><span class="line"></span><br><span class="line"># 提交暂存区的指定文件到仓库区</span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"></span><br><span class="line"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"># 提交时显示所有diff信息</span><br><span class="line">$ git commit -v</span><br><span class="line"></span><br><span class="line"># 使用一次新的commit，替代上一次提交</span><br><span class="line"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"></span><br><span class="line"># 重做上一次commit，并包括指定文件的新变化</span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h5 id="六，标签"><a href="#六，标签" class="headerlink" title="六，标签"></a>六，标签</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 列出所有tag</span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"># 新建一个tag在当前commit</span><br><span class="line">$ git tag [tag]</span><br><span class="line"></span><br><span class="line"># 新建一个tag在指定commit</span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"></span><br><span class="line"># 删除本地tag</span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"></span><br><span class="line"># 删除远程tag</span><br><span class="line">$ git push origin :refs&#x2F;tags&#x2F;[tagName]</span><br><span class="line"></span><br><span class="line"># 查看tag信息</span><br><span class="line">$ git show [tag]</span><br><span class="line"></span><br><span class="line"># 提交指定tag</span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"></span><br><span class="line"># 提交所有tag</span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"></span><br><span class="line"># 新建一个分支，指向某个tag</span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h5 id="七，远程同步"><a href="#七，远程同步" class="headerlink" title="七，远程同步"></a>七，远程同步</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h5 id="八，撤销"><a href="#八，撤销" class="headerlink" title="八，撤销"></a>八，撤销</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 恢复暂存区的指定文件到工作区</span><br><span class="line">$ git checkout [file]</span><br><span class="line"></span><br><span class="line"># 恢复某个commit的指定文件到暂存区和工作区</span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"></span><br><span class="line"># 恢复暂存区的所有文件到工作区</span><br><span class="line">$ git checkout .</span><br><span class="line"></span><br><span class="line"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line"># 重置暂存区与工作区，与上一次commit保持一致</span><br><span class="line">$ git reset --hard</span><br><span class="line"></span><br><span class="line"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br><span class="line">$ git reset [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"></span><br><span class="line"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"></span><br><span class="line"># 新建一个commit，用来撤销指定commit</span><br><span class="line"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br><span class="line">$ git revert [commit]</span><br><span class="line"></span><br><span class="line"># 暂时将未提交的变化移除，稍后再移入</span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h5 id="十，其他"><a href="#十，其他" class="headerlink" title="十，其他"></a>十，其他</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成一个可供发布的压缩包</span><br><span class="line">$ git archive</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Git</category>
        <category>Git的git基础命令</category>
      </categories>
      <tags>
        <tag>git 命令</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/23/docker03/</url>
    <content><![CDATA[<h3 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h3><ol>
<li>创建docker-compose.yml <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">    redis:</span><br><span class="line">        image: redis</span><br><span class="line">        expose:</span><br><span class="line">            - 6379</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;6389:6379&quot;</span><br><span class="line">    mysql:</span><br><span class="line">        image: mysql:5.5</span><br><span class="line">        expose:</span><br><span class="line">            - 3306</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;3307:3306&quot;</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_ROOT_PASSWORD: python</span><br><span class="line">            MYSQL_USER: root</span><br><span class="line">        volumes:</span><br><span class="line">            - .&#x2F;02_mysql:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">    flask:</span><br><span class="line">        build: .&#x2F;01_flask</span><br><span class="line">        volumes:</span><br><span class="line">            - .&#x2F;01_flask&#x2F;project:&#x2F;home&#x2F;project</span><br><span class="line">        ports:</span><br><span class="line">            - &quot;5000:5000&quot;</span><br><span class="line">        depends_on:</span><br><span class="line">            - mysql</span><br><span class="line">            - redis</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h4></li>
</ol>
<ul>
<li>生成容器并运行<ul>
<li><code>docker-compose up</code></li>
</ul>
</li>
<li>删除容器 <ul>
<li><code>docker-compose down</code></li>
</ul>
</li>
<li>开启容器并运行<ul>
<li><code>docker-compose start</code></li>
</ul>
</li>
<li>停止容器运行<ul>
<li><code>docker-compose stop</code></li>
</ul>
</li>
</ul>
<p><strong>depends_on</strong><br><img src="docker03.assets/647_1.png"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/27/javaInterface/</url>
    <content><![CDATA[<h4 id="jdk8-之后，接口提供了默认方法"><a href="#jdk8-之后，接口提供了默认方法" class="headerlink" title="jdk8 之后，接口提供了默认方法"></a>jdk8 之后，接口提供了默认方法</h4><ul>
<li><p>在接口里 可以写 有实现体的方法了，可以被重写，但是不强制</p>
</li>
<li><p>如果实现的多个接口有相同名字的默认方法，实现类必须重写</p>
<p><img src="javaInterface.assets/1619488312119.png" alt="1619488312119"></p>
</li>
</ul>
<h4 id="jdk8-之后，接口提供了静态方法"><a href="#jdk8-之后，接口提供了静态方法" class="headerlink" title="jdk8 之后，接口提供了静态方法"></a>jdk8 之后，接口提供了静态方法</h4><p><img src="javaInterface.assets/1619489768318.png" alt="1619489768318"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/14/javaday02/</url>
    <content><![CDATA[<h3 id="java-跨包使用"><a href="#java-跨包使用" class="headerlink" title="java 跨包使用"></a>java 跨包使用</h3><p><img src="javaday02.assets/1618281252388.png" alt="1618281252388"></p>
<h3 id="集合与数组的区别"><a href="#集合与数组的区别" class="headerlink" title="集合与数组的区别"></a>集合与数组的区别</h3><p>数组 长度不能修改</p>
<p>list   长度可以改变</p>
<h3 id="Arraylist"><a href="#Arraylist" class="headerlink" title="Arraylist"></a>Arraylist</h3><h3 id="泛型-作为约束集合里的类型"><a href="#泛型-作为约束集合里的类型" class="headerlink" title="泛型 作为约束集合里的类型"></a>泛型 作为约束集合里的类型</h3><p><img src="javaday02.assets/1618303552657.png" alt="1618303552657"></p>
<h4 id="ArrayList-方法"><a href="#ArrayList-方法" class="headerlink" title="ArrayList 方法"></a>ArrayList 方法</h4><ul>
<li><p>增 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arrLi02.add(&quot;content&quot;);</span><br><span class="line">arrLi02.add(3,&quot;conge&quot;); &#x2F;&#x2F; 根据下标 添加</span><br></pre></td></tr></table></figure>

<p><strong>不能跨界添加</strong></p>
</li>
<li><p>删</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addLi02.remove(&quot;2&quot;); &#x2F;&#x2F; 根据元素</span><br><span class="line">addLi02.remove(0,&quot;2&quot;); &#x2F;&#x2F; 根据下标 删除元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addLi02.set(0,&quot;改&quot;); &#x2F;&#x2F; 参数1 下标， 参数2 元素</span><br></pre></td></tr></table></figure>
</li>
<li><p>查</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addLi02.get(0); &#x2F;&#x2F; 参数1 下标，</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 循环打印</span><br><span class="line">for (int i &#x3D; 0; i &lt; addLi02.size() ; i++) &#123;</span><br><span class="line">	System.out.println(addLi02.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>Java ArrayList forEach() 方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line"></span><br><span class="line">class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建一个数组</span><br><span class="line">        ArrayList&lt;Integer&gt; numbers &#x3D; new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 往数组中添加元素</span><br><span class="line">        numbers.add(1);</span><br><span class="line">        numbers.add(2);</span><br><span class="line">        numbers.add(3);</span><br><span class="line">        numbers.add(4);</span><br><span class="line">        System.out.println(&quot;ArrayList: &quot; + numbers);</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F; forEach 循环打印</span><br><span class="line">         for (Integer integer : numbers) &#123;</span><br><span class="line">            System.out.println(integer);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 所有元素乘以 10</span><br><span class="line">        System.out.print(&quot;更新 ArrayList: &quot;);</span><br><span class="line">       </span><br><span class="line">        &#x2F;&#x2F; 将 lambda 表达式传递给 forEach</span><br><span class="line">        numbers.forEach((e) -&gt; &#123;</span><br><span class="line">            e &#x3D; e * 10;</span><br><span class="line">            System.out.print(e + &quot; &quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList: [1, 2, 3, 4]</span><br><span class="line">更新 ArrayList: 10 20 30 40 </span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>js 逆向 项目 剖析</title>
    <url>/2020/12/25/js%E9%80%86%E5%90%91/</url>
    <content><![CDATA[<p>js 逆向 项目 剖析 </p>
<a id="more"></a>

<h2 id="今天通过两个案例i，来剖析，"><a href="#今天通过两个案例i，来剖析，" class="headerlink" title="今天通过两个案例i，来剖析，"></a>今天通过两个案例i，来剖析，</h2><h3 id="百度翻译"><a href="#百度翻译" class="headerlink" title="百度翻译"></a>百度翻译</h3><ul>
<li><p>通过页面分析，我们输入的hello ，返回的是json 数据</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605604002581.png~01style" alt="1605604002581"></p>
<p>  我们查看request headers， 得知token ，值不变，sign值，会，变动，</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605604212995.png~01style" alt="1605604212995"></p>
</li>
<li><p>因此得出js 代码，控制</p>
<p>  我们通过全局搜索，sign，值，发现，并未找到</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605605300191.png~01style" alt="1605605300191"></p>
<p>  我们又通过全局搜索，token，值，发现，并未找到</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605605369742.png~01style" alt="1605605369742"></p>
<p>  我们又从url 入手，Request URL: <a href="https://fanyi.baidu.com/v2transapi?from=en&amp;to=zh">https://fanyi.baidu.com/v2transapi?from=en&amp;to=zh</a></p>
<p>  分析， 取 v2transapi  进行全局搜索</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605605522648.png~01style" alt="1605605522648"></p>
<p>  貌似，找到，，我们一个个点击</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605605574174.png~01style" alt="1605605574174"></p>
<p>  可以看到sign 是个 函数，</p>
<p>  我们点击函数，进去，</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605606666012.png~01style" alt="1605606666012"></p>
<p>  我们复制，js 代码下来， 保存为js文件</p>
<p>  通过 pip install PyExecJs</p>
<p>  来运行，</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import execjs</span><br><span class="line"></span><br><span class="line">with open(&quot;百度翻译.js&quot;, &quot;r&quot;, encoding&#x3D;&quot;utf-8&quot;) as f:</span><br><span class="line">    js_content &#x3D; f.read()</span><br><span class="line"></span><br><span class="line">    # python执行js代码</span><br><span class="line">    context &#x3D; execjs.compile(js_content)</span><br><span class="line"></span><br><span class="line">    # --------------注意--------------</span><br><span class="line">    # context指向了要执行的js文件，如果想要调用某个函数，可以用下面的call方法</span><br><span class="line">    # 第1个参数，为需要调用的函数名字</span><br><span class="line">    # 第2个参数，为给函数e传递的参数（是否传递要看调用的函数是否需要实参）</span><br><span class="line">    ret &#x3D; context.call(&quot;e&quot;, &quot;happy new year my baby&quot;)</span><br><span class="line">    print(ret)</span><br></pre></td></tr></table></figure>

<p>  发生异常</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605606927261.png~01style" alt="1605606927261"></p>
<p>  我们从 浏览器， 中找 i的值， 在哪，</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605608060236.png~01style" alt="1605608060236"></p>
<p>  记住了，得加个断点，多次， 运行发现它是个写死的值</p>
<p>  但是，我们还是想知道，这个值在哪</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605608493510.png~01style" alt="1605608493510"></p>
<p>  我们再次运行，js， 又发生了异常</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605608641465.png~01style" alt="1605608641465"></p>
<p>  同样我们去 ，浏览器上找</p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605608599858.png~01style" alt="1605608599858"></p>
<p>  我们把 这个n 函数，同样放入，js代码中，</p>
<p>  再次运行， 发现了， </p>
<p>  <img src="http://qny.jkraise.top/js%E9%80%86%E5%90%91assets/1605608849950.png~01style" alt="1605608849950"></p>
<p>  这样就解决了，sign</p>
<p>  组成，data数据，发送 请求， 完成 翻译</p>
<h3 id="百度招聘"><a href="#百度招聘" class="headerlink" title="百度招聘"></a>百度招聘</h3></li>
</ul>
<ol>
<li><p>搜索Python 职位， 在北京的职位</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url &#x3D; http:&#x2F;&#x2F;zhaopin.baidu.com&#x2F;quanzhi?query&#x3D;Python&amp;city&#x3D;%E5%8C%97%E4%BA%AC</span><br></pre></td></tr></table></figure>
</li>
<li><p>发现，ajax 加载数据，</p>
</li>
<li></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>







<p>​    </p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>爬虫 js 逆向</category>
      </categories>
      <tags>
        <tag>爬虫 js 逆向</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/04/13/jvm%E5%A0%86%E6%A0%88%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Jvm-堆-amp-栈的理解"><a href="#Jvm-堆-amp-栈的理解" class="headerlink" title="Jvm 堆&amp;栈的理解"></a>Jvm 堆&amp;栈的理解</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p> JVM里的“堆”（heap）特指用于存放Java对象的内存区域 </p>
<p><strong>要注意，这个“堆”并不是数据结构意义上的堆（<a href="https://link.zhihu.com/?target=https://en.wikipedia.org/wiki/Heap_(data_structure)">Heap (data structure)</a>，一种有序的树），而是动态内存分配意义上的堆——用于管理动态生命周期的内存区域</strong></p>
<p> <strong>JVM的堆被同一个JVM实例中的所有Java线程共享。它通常由某种自动内存管理机制所管理，这种机制通常叫做“垃圾回收”（garbage collection，GC）</strong> </p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p> JVM里的“栈”（ stack ）特指用于存放Java方法 ，基本类型的变量，和对象的引用变量 ，的内存区域 </p>
<p><strong>特点是 先进后出</strong></p>
<p>方法执行后，方法会从栈里出去，释放</p>
<p> 存取速度比堆要快，仅此于寄存器，栈数据可以共享，但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。 </p>
<h2 id="栈和堆的区别"><a href="#栈和堆的区别" class="headerlink" title="栈和堆的区别"></a>栈和堆的区别</h2><blockquote>
<p>JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</p>
</blockquote>
<ul>
<li>差异</li>
</ul>
<blockquote>
<p>1.堆内存用来存放由new创建的对象和数组。<br>2.栈内存用来存放方法或者局部变量等<br>3.堆是先进先出，后进后出<br>4.栈是后进先出，先进后出</p>
</blockquote>
<ul>
<li>相同</li>
</ul>
<blockquote>
<p>1.都是属于Java内存的一种<br>2.系统都会自动去回收它，但是对于堆内存一般开发人员会自动回收它</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>数据库的导出命令</title>
    <url>/2021/04/11/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%87%BA/</url>
    <content><![CDATA[<p>mysqldump -u 用户名 -p 数据库 &gt; 导出的文件名<br>mysqldump -uroot -pmysql db_name &gt; test_db.sql</p>
<a id="more"></a>
<h2 id="数据库的导出命令"><a href="#数据库的导出命令" class="headerlink" title="数据库的导出命令"></a>数据库的导出命令</h2><h4 id="导出数据库（SQL脚本）"><a href="#导出数据库（SQL脚本）" class="headerlink" title="导出数据库（SQL脚本）"></a>导出数据库（SQL脚本）</h4><p>mysqldump -u 用户名 -p 数据库 &gt; 导出的文件名</p>
<p>mysqldump -uroot -pmysql db_name &gt; test_db.sql</p>
<h4 id="导出数据库的一个表"><a href="#导出数据库的一个表" class="headerlink" title="导出数据库的一个表"></a>导出数据库的一个表</h4><p>mysqldump -u 用户名 -p数据库 b表名 &gt; 导出的文件名</p>
<p>mysqldump -u root -p test_db users &gt; test_users.sql </p>
<h4 id="导出所有数据库"><a href="#导出所有数据库" class="headerlink" title="导出所有数据库"></a>导出所有数据库</h4><p>mysqldump -uroot -p –all-databases &gt; /DestTop/all_db.sql</p>
<h4 id="条件导出，导出test表b2中id-6的数据"><a href="#条件导出，导出test表b2中id-6的数据" class="headerlink" title="条件导出，导出test表b2中id=6的数据"></a>条件导出，导出test表b2中id=6的数据</h4><p>mysqldump -uroot -p test b2 –where=’id=6’ &gt; /DestTop/all_db.sql</p>
<p>mysqldump -uroot -p –databases test –tables b2 –where=’id=6’ &gt; /DestTop/all_db.sql</p>
<h4 id="导出表结构不导出数据，-–no-data"><a href="#导出表结构不导出数据，-–no-data" class="headerlink" title="导出表结构不导出数据， –no-data"></a>导出表结构不导出数据， –no-data</h4><p>mysqldump -uroot -p –no-data db1 &gt; /desktop/db1.sql</p>
<h4 id="跨服务器导出导入数据"><a href="#跨服务器导出导入数据" class="headerlink" title="跨服务器导出导入数据"></a>跨服务器导出导入数据</h4><p>mysqldump –host=h1 -uroot -proot –databases db1 |mysql –host=h2 -uroot -proot db2</p>
<h4 id="导入数据库"><a href="#导入数据库" class="headerlink" title="导入数据库"></a>导入数据库</h4><p>source mydb.sql</p>
<p>mysql -u用户 -p 数据库名 &lt;  数据库名.sql</p>
<h4 id="感谢大佬的技术博客"><a href="#感谢大佬的技术博客" class="headerlink" title="感谢大佬的技术博客"></a><a href="https://www.cnblogs.com/chenmh/p/5300370.html">感谢大佬的技术博客</a></h4>]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>MySQL数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas 数据处理02  groupby</title>
    <url>/2020/12/28/pandas02/</url>
    <content><![CDATA[<p> pandas 数据处理02 聚合分组 </p>
<a id="more"></a>

<h4 id="时间戳-转换时间"><a href="#时间戳-转换时间" class="headerlink" title="时间戳 转换时间"></a>时间戳 转换时间</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">df &#x3D; pd.read_csv(&quot;.&#x2F;train.csv&quot;)</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line">d_time &#x3D; pd.to_datetime(df[&#39;time&#39;], unit&#x3D;&#39;s&#39;)</span><br><span class="line">print(type(d_time)) # &lt;class &#39;pandas.core.series.Series&#39;&gt;</span><br><span class="line">print(&#39;--------------&#39;)</span><br><span class="line">print(d_time)</span><br></pre></td></tr></table></figure>



<h4 id="时间值-处理"><a href="#时间值-处理" class="headerlink" title="时间值 处理"></a>时间值 处理</h4><p><img src="http://qny.jkraise.top/pandas02assets/1609116502837.png~01style" alt="1609116502837"></p>
<h4 id="删除-缺失值-dropna"><a href="#删除-缺失值-dropna" class="headerlink" title="删除 缺失值 dropna"></a>删除 缺失值 dropna</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;./breast-cancer-wisconsin.data&#x27;</span>)</span><br><span class="line"></span><br><span class="line">df = df.replace(to_replace=<span class="string">&#x27;?&#x27;</span>, value=np.nan)</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line">print(<span class="string">&#x27;--------------&#x27;</span>)</span><br><span class="line"><span class="comment"># 默认是0 删除行数据  为1 删除列数据</span></span><br><span class="line"><span class="comment"># how=&#x27;all&#x27; 全部是nan 删除</span></span><br><span class="line"><span class="comment"># how=&#x27;any&#x27; 有nan就删除</span></span><br><span class="line"></span><br><span class="line">df1 = df.dropna(axis=<span class="number">0</span>, how=<span class="string">&#x27;all&#x27;</span>)</span><br><span class="line">print(df1)</span><br></pre></td></tr></table></figure>

<h4 id="pandas的合并"><a href="#pandas的合并" class="headerlink" title="pandas的合并"></a>pandas的合并</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df_data = pd.read_csv(<span class="string">&#x27;./directory.csv&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment"># 指定列的 合并</span></span><br><span class="line">pd.merge()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>merge 案例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 商品详情 product_id 商品的名字 和 aisle_id</span></span><br><span class="line">product = pd.read_csv(<span class="string">&quot;C:/Users/halon/Desktop/数据挖掘/day05/instacart/products.csv&quot;</span>)</span><br><span class="line"><span class="comment"># orderid  product_id</span></span><br><span class="line">order_pro = pd.read_csv(<span class="string">&quot;C:/Users/halon/Desktop/数据挖掘/day05/instacart/order_products__prior.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># orderId  userId</span></span><br><span class="line">orders = pd.read_csv(<span class="string">&quot;C:/Users/halon/Desktop/数据挖掘/day05/instacart/orders.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># aisles_nameid  aislesId</span></span><br><span class="line">aisles = pd.read_csv(<span class="string">&quot;C:/Users/halon/Desktop/数据挖掘/day05/instacart/aisles.csv&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并product和order_pro, 通过product_id</span></span><br><span class="line">mg1 = pd.merge(order_pro, product, on=[<span class="string">&#x27;product_id&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并mg1 和orders 通过order_id</span></span><br><span class="line">mg2 = pd.merge(mg1, orders, on=[<span class="string">&#x27;order_id&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并mg2 和aisles 通过aisle_id</span></span><br><span class="line">mg3 = pd.merge(mg2, aisles, on=[<span class="string">&#x27;aisle_id&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户购买的所有类商品的数量</span></span><br><span class="line">user_ai = pd.crosstab(mg3[<span class="string">&#x27;user_id&#x27;</span>],mg3[<span class="string">&#x27;aisle&#x27;</span>])</span><br><span class="line">print(user_ai)</span><br></pre></td></tr></table></figure>



<h4 id="聚合分组1"><a href="#聚合分组1" class="headerlink" title="聚合分组1"></a>聚合分组1</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">df_data = pd.read_csv(<span class="string">&#x27;./directory.csv&#x27;</span>)</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment"># 按国家分组</span></span><br><span class="line">df_country = df.groupby(<span class="string">&#x27;Country&#x27;</span>)</span><br><span class="line">print(df_country.count().reset_index())</span><br><span class="line"><span class="comment"># 按国家 和省分组</span></span><br><span class="line">df_country_Province = df.gourpby([<span class="string">&#x27;Country&#x27;</span>,<span class="string">&#x27;State/Province&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据</span></span><br><span class="line">print(df_country_Province.count().reset_index())</span><br></pre></td></tr></table></figure>

<p>聚合函数+分组</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df = pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&#x27;color&#x27;</span>: [<span class="string">&#x27;white&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;object&#x27;</span>: [<span class="string">&#x27;pen&#x27;</span>, <span class="string">&#x27;pencil&#x27;</span>, <span class="string">&#x27;pencil&#x27;</span>, <span class="string">&#x27;ashtray&#x27;</span>, <span class="string">&#x27;pen&#x27;</span>],</span><br><span class="line">    <span class="string">&#x27;price1&#x27;</span>: [<span class="number">5.56</span>, <span class="number">4.20</span>, <span class="number">1.30</span>, <span class="number">0.56</span>, <span class="number">2.75</span>],</span><br><span class="line">    <span class="string">&#x27;price2&#x27;</span>: [<span class="number">4.75</span>, <span class="number">4.12</span>, <span class="number">1.60</span>, <span class="number">0.75</span>, <span class="number">3.15</span>]</span><br><span class="line">&#125;)</span><br><span class="line">      </span><br><span class="line">print(df)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先分组， 后聚合</span></span><br><span class="line">df_color = df.groupby(<span class="string">&#x27;color&#x27;</span>)</span><br><span class="line">print(type(df_color))</span><br><span class="line">print(df_color.mean())</span><br><span class="line">print(df_color.max())</span><br><span class="line">print(<span class="string">&#x27;---------------------------------&#x27;</span>)</span><br><span class="line"><span class="comment"># 第二种  先聚合 再分组 （不常用）</span></span><br><span class="line">price_m = df[<span class="string">&#x27;price2&#x27;</span>].groupby(df[<span class="string">&#x27;color&#x27;</span>]).mean()</span><br><span class="line">print(price_m)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>pandas 数据处理</category>
      </categories>
      <tags>
        <tag>pandas 数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>pandas 数据清洗</title>
    <url>/2020/12/25/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97/</url>
    <content><![CDATA[<p>pandas 数据清洗</p>
<a id="more"></a>
<h2 id="一，数据预处理"><a href="#一，数据预处理" class="headerlink" title="一，数据预处理"></a>一，数据预处理</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p><strong>首先</strong>  安装pandas</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install pandas</span><br></pre></td></tr></table></figure>

<hr>
<p>导包 pandas</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br></pre></td></tr></table></figure>

<p>加载 数据集，代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; pd.read_csv(&#39;..&#x2F;data&#x2F;move.csv&#39;)</span><br></pre></td></tr></table></figure>

<p>Pandas 提供了一些选择的方法，</p>
<ul>
<li><p>查看一列的一些基本统计信息： <code>data.columnname.describe()</code></p>
</li>
<li><p>选择一列：<code>dada[&#39;columnname&#39;]</code></p>
</li>
<li><p>选择一列的前几行数据：<code>data[&#39;columnname&#39;][:n]</code></p>
</li>
<li><p>选择多列：<code>data[[&#39;column1&#39;, &#39;column2&#39;]]</code></p>
</li>
<li><p>Where 条件过滤：<code>data[data[&#39;columnname&#39;] &gt; condition]</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data &#x3D; pd.read_csv(&#39;movie_metadata.csv&#39;)</span><br><span class="line"># 打印 前5行数据</span><br><span class="line"># print(data.head())</span><br><span class="line"></span><br><span class="line"># 打印 某列 前5行</span><br><span class="line"># print(data[&#39;director_name&#39;][:5])</span><br><span class="line"></span><br><span class="line"># 打印 多列 数据</span><br><span class="line"># print(data[[&#39;director_name&#39;, &#39;aspect_ratio&#39;]])</span><br><span class="line"></span><br><span class="line"># 打印 多列 5行 数据</span><br><span class="line"># print(data[[&#39;director_name&#39;, &#39;aspect_ratio&#39;]][:5])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>一般有这几个方法，</p>
<ul>
<li><p>为缺失数据赋值默认值</p>
</li>
<li><p>去掉/删除缺失数据行</p>
</li>
<li><p>去掉/删除缺失率高的列</p>
</li>
</ul>
<p><strong>添加默认值</strong></p>
<ul>
<li><p>我们去掉NaN值，我们检查了“country”列，这一列表示地区，然而有一些电影没有提供地区，我们将 ”country“ 整个列，使用 “” 空字符串替换了，或者，我们可以使用”None Given” 进行替换，</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加默认值 &#39;&#39;</span><br><span class="line"># data.country&#x3D; data.country.fillna(&#39;&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数字类型的数据(计算电影的平均值)</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.duration &#x3D; data.duration.fillna(data.duration.mean())</span><br></pre></td></tr></table></figure>

<p>  如果想了解更多 fillna() 的详细信息参考<a href="https://link.zhihu.com/?target=https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html">pandas.DataFrame.fillna</a>。 </p>
</li>
</ul>
<p><strong>删除不完整的行</strong></p>
<p>假设，我们想删除任何有缺失值的行，这种操作太据侵略性，但是我们可以根据的我们的需要进行扩展</p>
<ul>
<li><p>删除任何包含NA值的行</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.dropna()</span><br></pre></td></tr></table></figure>
</li>
<li><p>当然我们可以删除一整行的值为NA：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.dropna(how&#x3D;&#39;all&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们可以加条件，在一行中有多少非空值的数据是可以保留下来的（例子中，行数据中至少有5个非空值）</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.drop(thresh&#x3D;5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>比如说，我们不想要不知道电影上映时间的数据：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.dropna(subset&#x3D;[&#39;title_year&#39;])</span><br></pre></td></tr></table></figure>

<p>  上面的subset 参数允许我们选择想要检查的列，如果是多个列，可以使用列名的list 作为参数</p>
</li>
</ul>
<p><strong>删除不完整的列</strong></p>
<p>我们可以使用axis=1 参数，这个意思就是操作列而不是行，（如果我们不传参数axis，默认是axis=0）</p>
<ul>
<li><p>删除一整列为NA的列：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.drop(axis&#x3D;1, how&#x3D;&#39;all&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除任何包含空值的列</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data.drop(axis&#x3D;1,how&#x3D;&#39;any&#39;)</span><br></pre></td></tr></table></figure>

<p>  这里也可以使用上面一样的threshold 和subset  更多的详情和案例，请参考<a href="https://link.zhihu.com/?target=https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.dropna.html">pandas.DataFrame.dropna</a>。 </p>
</li>
</ul>
<h3 id="规范化数据类型"><a href="#规范化数据类型" class="headerlink" title="规范化数据类型"></a>规范化数据类型</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#数据类型转换:字符串转换为日期</span><br><span class="line">#errors&#x3D;&#39;coerce&#39; 如果原始数据不符合日期的格式，转换后的值为空值NaT</span><br><span class="line"></span><br><span class="line">DataDF.loc[:,&#39;InvoiceDate&#39;]&#x3D;pd.to_datetime(DataDF.loc[:,&#39;InvoiceDate&#39;],</span><br><span class="line">                                           format&#x3D;&#39;%d&#x2F;%m&#x2F;%Y&#39;, </span><br><span class="line">                                           errors&#x3D;&#39;coerce&#39;)</span><br><span class="line"></span><br><span class="line">#!!⚠️ format 是你［原始数据］中日期的格式</span><br><span class="line"></span><br><span class="line">%y 两位数的年份表示（00-99）</span><br><span class="line">%Y 四位数的年份表示（000-9999）</span><br><span class="line">%m 月份（01-12）</span><br><span class="line">%d 月内中的一天（0-31）</span><br><span class="line">%H 24小时制小时数（0-23）</span><br><span class="line">%I 12小时制小时数（01-12）</span><br><span class="line">%M 分钟数（00-59）</span><br><span class="line">%S 秒（00-59）</span><br></pre></td></tr></table></figure>

<p><img src="http://qny.jkraise.top/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97.assets/1606058177255.png~01style" alt="1606058177255"></p>
<p>调整后</p>
<p><img src="http://qny.jkraise.top/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97.assets/1606058204326.png~01style" alt="1606058204326"></p>
<p><strong>修改列名</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#建立字典字典：旧列名和新列名对应关系</span><br><span class="line">colNameDict &#x3D; &#123;&#39;InvolceDate&#39;:&#39;SaleDate&#39;,&#39;StockCode&#39;:&#39;StockNo&#39;&#125;     </span><br><span class="line"></span><br><span class="line">#!! ⚠️一定要旧列名放在冒号前</span><br><span class="line">#每组对应关系以［逗号］隔开</span><br><span class="line"></span><br><span class="line">salesDf.rename(columns &#x3D; colNameDict,inplace&#x3D;True)</span><br></pre></td></tr></table></figure>

<p><strong>选择部分子集</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#选择子集，选择其中一列</span><br><span class="line">subDataDF1&#x3D;DataDF[&quot;InvoiceDate&quot;]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#选择子集，选择其中两列</span><br><span class="line">subDataDF1&#x3D;DataDF[[&quot;InvoiceDate&quot;,&quot;UnitPrice&quot;]]</span><br></pre></td></tr></table></figure>

<p>** <strong>利用切片筛选数据功能 df.loc</strong> **</p>
<p><a href="https://link.zhihu.com/?target=https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.loc.html%23pandas.DataFrame.loc">loc资料，文档</a></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">subDataDF1=DataDF.loc[:,&quot;InvoiceDate&quot;]</span><br><span class="line">subDataDF1</span><br><span class="line">#单一个冒号意味着不作限制的全选</span><br></pre></td></tr></table></figure>

<p><img src="http://qny.jkraise.top/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97.assets/1606059005058.png~01style" alt="1606059005058"></p>
<p><img src="http://qny.jkraise.top/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97.assets/1606059218685.png~01style" alt="1606059218685"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">subDataDF2=DataDF.loc[0:9,:]</span><br><span class="line">subDataDF2</span><br></pre></td></tr></table></figure>

<p><img src="http://qny.jkraise.top/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97.assets/1606059255274.png~01style" alt="1606059255274"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">subDataDF3=DataDF.loc[1:9,&quot;StockCode&quot;:&quot;CustomerID&quot;]</span><br><span class="line">subDataDF3</span><br></pre></td></tr></table></figure>

<p><img src="http://qny.jkraise.top/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97.assets/1606059322603.png~01style" alt="1606059322603"></p>
<p><strong>逻辑问题需要筛选</strong></p>
<p><strong>还是Dataframe.loc这个函数的知识点。</strong></p>
<p><strong>由于loc还可以判断条件是否为True</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">DataDF.loc[:,&#x27;UnitPrice&#x27;]&gt;0</span><br></pre></td></tr></table></figure>

<p><img src="http://qny.jkraise.top/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97.assets/1606059397428.png~01style" alt="1606059397428"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#删除异常值：通过条件判断筛选出数据</span><br><span class="line">#查询条件</span><br><span class="line">querySer=DataDF.loc[:,&#x27;Quantity&#x27;]&gt;0</span><br><span class="line">#应用查询条件</span><br><span class="line">print(&#x27;删除异常值前：&#x27;,DataDF.shape)</span><br><span class="line">DataDF=DataDF.loc[querySer,:]</span><br><span class="line">print(&#x27;删除异常值后：&#x27;,DataDF.shape)</span><br></pre></td></tr></table></figure>

<p><img src="http://qny.jkraise.top/pandas%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97.assets/1606059510619.png~01style" alt="1606059510619"></p>
<p><strong>格式化处理</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">str().</span><br><span class="line">upper()</span><br><span class="line">lower()</span><br><span class="line">title() </span><br><span class="line">lstrip()</span><br><span class="line">strip()</span><br><span class="line"></span><br><span class="line">DataDF[&#x27;Description&#x27;]= DataDF[&#x27;Description&#x27;].str.strip()</span><br></pre></td></tr></table></figure>

<p>空格分割</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">#定义函数：分割InvoiceDate，获取InvoiceDate</span><br><span class="line">#输入：timeColSer InvoiceDate这一列，是个Series数据类型</span><br><span class="line">#输出：分割后的时间，返回也是个Series数据类型</span><br><span class="line"></span><br><span class="line">def splitSaletime(timeColSer):</span><br><span class="line">    timeList=[]</span><br><span class="line">    for value in timeColSer:</span><br><span class="line">        #例如2018/01/01 12:50，分割后为：2018-01-01</span><br><span class="line">        dateStr=value.split(&#x27; &#x27;)[0]</span><br><span class="line">        timeList.append(dateStr)</span><br><span class="line">#将列表转行为一维数据Series类型</span><br><span class="line">    timeSer=pd.Series(timeList)</span><br><span class="line">    return timeSer</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在赋值回去</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DataDF.loc[:,&#39;InvoiceDate&#39;]&#x3D;splitSaletime(DataDF.loc[:,&#39;InvoiceDate&#39;]) </span><br></pre></td></tr></table></figure>

<p><strong>处理缺失值</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 再一次提醒检查缺失数据</span><br><span class="line"></span><br><span class="line">DataDF.isnull().sum().sort_values(ascending=False)</span><br></pre></td></tr></table></figure>

<p><strong>去除缺失值的知识点：</strong></p>
<p><strong>DataFrame.dropna</strong></p>
<p><strong>DataFrame.dropna(axis=0, how=’any’, thresh=None, subset=None, inplace=False)</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># 默认（axis＝0）是逢空值剔除整行，设置关键字参数axis＝1表示逢空值去掉整列</span><br><span class="line"># &#x27;any&#x27;如果一行（或一列）里任何一个数据有任何出现Nan就去掉整行，</span><br><span class="line">  ‘all’一行（或列）每一个数据都是Nan才去掉这整行</span><br><span class="line"></span><br><span class="line">DataDF.dropna(how=&#x27;any&#x27;)</span><br><span class="line">DataDF.dropna(how=&#x27;all&#x27;)</span><br><span class="line"></span><br><span class="line"># 更精细的thresh参数，它表示留下此行（或列）时，要求有多少［非缺失值］</span><br><span class="line">DataDF.dropna(thresh = 6 )</span><br></pre></td></tr></table></figure>

<p>以上内容，参考于<a href="https://zhuanlan.zhihu.com/p/32572237">https://zhuanlan.zhihu.com/p/32572237</a>  这篇知乎，侵权必删，</p>
<p>以上内容，参考于<a href="https://zhuanlan.zhihu.com/p/60241672">https://zhuanlan.zhihu.com/p/60241672</a>  这篇知乎，侵权必删，</p>
]]></content>
      <categories>
        <category>pandas 数据清洗</category>
        <category>爬虫 数据清洗</category>
      </categories>
      <tags>
        <tag>pandas 数据 清洗</tag>
        <tag>爬虫框架scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>xpath 语法</title>
    <url>/2020/10/09/xpath%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p> xpath 语法</p>
<a id="more"></a>



<p> 相信写过爬虫的同学，都知道XPath的存在。博主最近在学习<a href="https://link.jianshu.com/?t=http://scrapy-chs.readthedocs.io/zh_CN/1.0/topics/debug.html">Scrapy</a>的时候，就了解了一下XPath语法，这里给大家简单地介绍一下： </p>
<h4 id="节点（node）"><a href="#节点（node）" class="headerlink" title="节点（node）"></a>节点（node）</h4><p> 在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点。XML 文档是被作为节点树来对待的。树的根被称为文档节点或者根节点。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span> <span class="attr">gender</span>=<span class="string">&quot;boy&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ID</span>&gt;</span>24<span class="tag">&lt;/<span class="name">ID</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span> <span class="attr">gender</span>=<span class="string">&quot;girl&quot;</span>&gt;</span>Li Rose<span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span>（monitor）<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ID</span>&gt;</span>1<span class="tag">&lt;/<span class="name">ID</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>以上例子的节点为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;classs&gt; （文档节点&#x2F;根节点）</span><br><span class="line">&lt;ID&gt;24&lt;&#x2F;ID&gt; （元素节点）</span><br><span class="line">gender&#x3D;&quot;boy&quot; （属性节点） </span><br></pre></td></tr></table></figure>

<p><strong>节点关系</strong></p>
<p>父：每个元素以及属性都有一个父。例子中<student>的父是<class>;<br> 子：元素节点可有零个、一个或多个子。例子中<class>的子是<student>;<br> 兄弟：拥有相同的父的节点。例子中<name>和<ID>是兄弟;<br> 祖先：某节点的父、父的父，等等。<br> 后代：某节点的子、子的子，等等。</p>
<p><strong>1. nodeName</strong></p>
<p>选取此节点的所有子节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> scrapy <span class="keyword">import</span> Selector</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parsel</span>(<span class="params">self, response</span>):</span></span><br><span class="line">	<span class="comment"># 生成xpath 对象</span></span><br><span class="line">	selector = Selector(response)</span><br><span class="line">	content = selector.xpath(<span class="string">&quot;class&quot;</span>)  <span class="comment"># 选取 class 元素的所有子节点。</span></span><br></pre></td></tr></table></figure>

<p><strong>2./</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scrapy import Selector</span><br><span class="line"></span><br><span class="line">def parsel(self, response):</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	选取根元素 class。</span><br><span class="line">    注释：假如路径起始于正斜杠( &#x2F; )，则此路径始终代表到某元素的绝对路径！</span><br><span class="line">	&quot;&quot;&quot;</span><br><span class="line">	# 生成xpath 对象</span><br><span class="line">	selector &#x3D; Selector(response)</span><br><span class="line">	content1&#x3D;selector.xpath(&quot;&#x2F;class&quot;)</span><br><span class="line">    content2&#x3D;selector.xpath(&quot;&#x2F;class&#x2F;student&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>3. //</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scrapy import Selector</span><br><span class="line"></span><br><span class="line">def parse(self, response):</span><br><span class="line">    selector&#x3D;Selector(response)</span><br><span class="line">    content&#x3D;selector.xpath(&#x2F;&#x2F;ID)# 选取所有ID子元素，而不管它们在文档中的位置。</span><br></pre></td></tr></table></figure>

<p><strong>4.  .</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选取当前节点</span><br></pre></td></tr></table></figure>

<p><strong>5.  ..</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选取当前的节点的父节点</span><br></pre></td></tr></table></figure>

<p><strong>6. @</strong></p>
<p>选取属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from scrapy import Selector</span><br><span class="line"></span><br><span class="line">def parse(self, response):</span><br><span class="line">    selector&#x3D;Selector(response)  </span><br><span class="line">    # 选取所有gender&#x3D;&quot;boy&quot;属性的节点，而不管它们在文档中的位置。</span><br><span class="line">    content&#x3D;selector.xpath(&#x2F;&#x2F;[@gender&#x3D;&quot;boy&quot;])	</span><br></pre></td></tr></table></figure>

<p><strong>7 谓语 （predicates）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;class&#x2F;student[1]  </span><br><span class="line">选取属于 class 子元素的第一个 student 元素。</span><br><span class="line"></span><br><span class="line">&#x2F;class&#x2F;student[last()]</span><br><span class="line">选取属于 class 子元素的最后一个 student 元素。</span><br><span class="line"></span><br><span class="line">&#x2F;class&#x2F;student[last()-1]</span><br><span class="line">选取属于 class 子元素的倒数第二个 student 元素。</span><br><span class="line"></span><br><span class="line">&#x2F;class&#x2F;student[position()&lt;3]</span><br><span class="line">选取属于 class 子元素的前两个 student 元素。</span><br><span class="line"></span><br><span class="line">&#x2F;class&#x2F;student[@gender]</span><br><span class="line">选取所有拥有名为 gender 的属性的 student 元素。</span><br><span class="line"></span><br><span class="line">&#x2F;class&#x2F;student[@gender&#x3D;&quot;boy&quot;]</span><br><span class="line">选取所有拥有 gender&#x3D;&quot;boy&quot; 属性的 student 元素。</span><br><span class="line"></span><br><span class="line">&#x2F;class&#x2F;student[ID&lt;50]</span><br><span class="line">选取 class 元素的所有 student 元素，且其中的 ID 元素的值须小于 50。</span><br><span class="line"></span><br><span class="line">&#x2F;class&#x2F;student[ID&lt;50]&#x2F;name</span><br><span class="line">选取 class 元素中的 student 元素的所有 name 元素，且其中的 ID 元素的值须小于 35。</span><br></pre></td></tr></table></figure>

<p><strong>8 通配符</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. *              匹配任何元素节点</span><br><span class="line">2. @*            匹配任何属性节点</span><br><span class="line">3. node()        匹配任何类型的节点</span><br></pre></td></tr></table></figure>

<p><strong>9 拓展</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;test2&quot;&gt;美女，&lt;font color&#x3D;red&gt;你的微信是多少？&lt;&#x2F;font&gt;&lt;div&gt;</span><br></pre></td></tr></table></figure>

<p>如果使用：<br> <code>data = selector.xpath(&#39;//div[@id=&quot;test2&quot;]/text()&#39;).extract()[0]</code><br> 只能提取到“美女，”；</p>
<p>如果使用：<br> <code>data = selector.xpath(&#39;//div[@id=&quot;test2&quot;]/font/text()&#39;).extract()[0]</code><br> 又只能提取到“你的微信是多少？”</p>
<p>到底我们要怎样才能把“美女，你的微信是多少”提取出来？</p>
<h5 id="可以使用xpath的string-来达到目的"><a href="#可以使用xpath的string-来达到目的" class="headerlink" title="可以使用xpath的string(.)来达到目的"></a>可以使用xpath的string(.)来达到目的</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data &#x3D; selector.xpath(&#39;&#x2F;&#x2F;div[@id&#x3D;&quot;test2&quot;])</span><br><span class="line">info &#x3D; data.xpath(&#39;string(.)&#39;).extract()[0]</span><br></pre></td></tr></table></figure>

<p>以上博客参照于 <a href="https://www.jianshu.com/p/2391950137a4">此博客</a></p>
<p> 转载请告知！！博主个人博客：<a href="https://www.jkraise.top/">http://www.jkraise.top</a><br>文章有不完善的地方，请留言告知！My lord </p>
]]></content>
      <categories>
        <category>xpath</category>
        <category>xpath的子目录</category>
      </categories>
      <tags>
        <tag>xpath 语法</tag>
        <tag>爬虫必备-语法</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/06/20/vue3.0/</url>
    <content><![CDATA[<h2 id="vue3-0"><a href="#vue3-0" class="headerlink" title="vue3.0"></a>vue3.0</h2>]]></content>
  </entry>
  <entry>
    <title>flask 项目使用redis数据库的原因</title>
    <url>/2020/10/09/%E4%BD%BF%E7%94%A8redis%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<p>flask 项目使用Redis内存型数据库的原因</p>
<a id="more"></a>

<h4 id="flask-项目使用Redis内存型数据库的原因"><a href="#flask-项目使用Redis内存型数据库的原因" class="headerlink" title="flask 项目使用Redis内存型数据库的原因"></a>flask 项目使用Redis内存型数据库的原因</h4><p>缓存用户常用的数据，提升用户到服务器的响应速度，提高用户的体验</p>
<p>不用则会降低响应，影响用户体验，</p>
<h4 id="Redis-与-mysql数据库的区别"><a href="#Redis-与-mysql数据库的区别" class="headerlink" title="Redis 与 mysql数据库的区别"></a>Redis 与 mysql数据库的区别</h4><p>Redis 存储在 内存中，内存存取数据， 速度快</p>
<p>mysql数据库 存储于硬盘， 存持久化数据，大量数据， <strong>jZnhp3</strong></p>
]]></content>
      <categories>
        <category>redis</category>
        <category>redis的子目录</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式 爬虫 Scrapy项目 scrapyd</title>
    <url>/2020/12/25/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%ABScrapy/</url>
    <content><![CDATA[<p>分布式 爬虫 Scrapy项目 scrapyd</p>
<a id="more"></a>

<h4 id="1、配置redis服务器允许远程连接"><a href="#1、配置redis服务器允许远程连接" class="headerlink" title="1、配置redis服务器允许远程连接"></a>1、配置redis服务器允许远程连接</h4><p>配置参考地址：<a href="https://www.cnblogs.com/masonblog/p/12726914.html">https://www.cnblogs.com/masonblog/p/12726914.html</a></p>
<h4 id="2-配置setting-文件"><a href="#2-配置setting-文件" class="headerlink" title="2. 配置setting 文件"></a>2. 配置setting 文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; scrapy-redis配置 &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 调度器类</span></span><br><span class="line">SCHEDULER = <span class="string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span></span><br><span class="line"><span class="comment"># 指纹去重类</span></span><br><span class="line">DUPEFILTER_CLASS = <span class="string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span></span><br><span class="line"><span class="comment"># 是否在关闭时候保留原来的调度器和去重记录，True=保留，False=清空</span></span><br><span class="line">SCHEDULER_PERSIST = <span class="literal">True</span></span><br><span class="line"><span class="comment"># Redis服务器地址</span></span><br><span class="line">REDIS_URL = <span class="string">&quot;redis://127.0.0.1:6379/1&quot;</span>  <span class="comment"># Redis默认有16库，/1的意思是使用序号为2的库，默认是0号库（这个可以任意）</span></span><br></pre></td></tr></table></figure>

<h4 id="开启爬虫"><a href="#开启爬虫" class="headerlink" title="开启爬虫"></a>开启爬虫</h4><p><strong>项目 说明</strong></p>
<ul>
<li><p>豆瓣电影top250  使用scrapyredis 分布式爬虫 进行， 爬取，</p>
</li>
<li><p>爬取 标题，图片</p>
</li>
</ul>
<ol>
<li><p>在节点1,2开启 （此时爬虫并未开始，而是等待Redis中 <code>top250:start_urls http://xxxxx</code></p>
<p> <img src="http://qny.jkraise.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%ABScrapy.assets/1607311850953.png~01style" alt="1607311850953"></p>
<p> <strong>因为 douban 爬虫 继承Redisspider 我们没有传入 start_urls</strong></p>
<p> 原因： 这个项目 实现的是分布式，也就意味着在其他节点 （服务器） 上，也是相同的，会出现爬取重复的 start_urls中的url  ，这是没有必要的</p>
<p> <img src="http://qny.jkraise.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%ABScrapy.assets/1607322864382.png~01style" alt="1607322864382"></p>
</li>
<li><p>我们需在 redis客户端 输入 push指令开启 爬虫 才是 真正开始（注意一定要选择setting.py 文件中的配置的数据库）</p>
 <figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$redis &gt; select <span class="number">2</span></span><br><span class="line">$redis &gt; lpush top250:start_urls https://movie.douban.com/top250?start=0&amp;filter=</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时 我们需要 把数据 合在一起，方案是 存入redis 中，</p>
<p> 通过中间件   会将信息Item 存储在Redis中</p>
<p> <img src="http://qny.jkraise.top/%E5%88%86%E5%B8%83%E5%BC%8F%E7%88%AC%E8%99%ABScrapy.assets/1607322864382.png~01style" alt="1607324372718"></p>
</li>
<li><p>我们从redis 中取出数据</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    <span class="comment"># 指定Redis数据库信息</span></span><br><span class="line">    redis_cli = redis.StrictRedis(host=<span class="string">&#x27;127.0.0.1&#x27;</span>, port=<span class="number">6379</span>, db=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否存在download文件夹，如果没有则创建</span></span><br><span class="line">    download_path = os.getcwd() + <span class="string">&#x27;/download/&#x27;</span>  <span class="comment"># 当前文件夹下的download文件夹</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(download_path):  <span class="comment"># 判断文件夹或文件</span></span><br><span class="line">        os.makedirs(download_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># FIFO模式为 blpop，LIFO模式为 brpop，获取键值</span></span><br><span class="line">        source, data = redis_cli.blpop([<span class="string">&quot;top250:items&quot;</span>])</span><br><span class="line"></span><br><span class="line">        item = json.loads(data.decode())  <span class="comment"># data.decode()目的，因为从Redis中提取到的数据时byte类型，所以转换为字符串类型</span></span><br><span class="line"></span><br><span class="line">        msg_type = item.get(<span class="string">&quot;type&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> msg_type == <span class="string">&quot;info&quot;</span>:</span><br><span class="line">            <span class="comment"># # 信息</span></span><br><span class="line">            <span class="comment"># &#123;</span></span><br><span class="line">            <span class="comment">#     &quot;type&quot;: &quot;info&quot;,</span></span><br><span class="line">            <span class="comment">#     &quot;img_src&quot;: img_src,</span></span><br><span class="line">            <span class="comment">#     &quot;title&quot;: title,</span></span><br><span class="line">            <span class="comment">#     &quot;rating_num&quot;: rating_num,</span></span><br><span class="line">            <span class="comment">#     &quot;people_num&quot;: people_num</span></span><br><span class="line">            <span class="comment"># &#125;</span></span><br><span class="line">            <span class="comment"># 如果是信息，就保存到csv文件</span></span><br><span class="line">            <span class="keyword">with</span> open(download_path + <span class="string">&#x27;豆瓣电影TOP250.csv&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="comment"># 创建一个csv的DictWriter对象，这样才能够将写入csv格式数据到这个文件</span></span><br><span class="line">                f_csv = csv.DictWriter(f, [<span class="string">&#x27;title&#x27;</span>, <span class="string">&#x27;img_src&#x27;</span>, <span class="string">&#x27;rating_num&#x27;</span>, <span class="string">&#x27;people_num&#x27;</span>])</span><br><span class="line">                <span class="comment"># 写入多行行（当做数据）</span></span><br><span class="line">                item.pop(<span class="string">&quot;type&quot;</span>)  <span class="comment"># 删除type 这个key-value</span></span><br><span class="line">                f_csv.writerows([item])</span><br><span class="line">                print(<span class="string">&quot;保存信息到CSV....ok&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> msg_type == <span class="string">&quot;img&quot;</span>:</span><br><span class="line">            <span class="comment"># 存储图片</span></span><br><span class="line">            <span class="keyword">with</span> open(download_path + item.get(<span class="string">&quot;img_name&quot;</span>), <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                img_data = base64.b64decode(item.get(<span class="string">&quot;img_bytes&quot;</span>))</span><br><span class="line">                f.write(img_data)</span><br><span class="line">                print(<span class="string">&quot;保存图片ok....&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意： 其中redis 不允许存入二进制数据</strong></p>
<p> ​    而 我们爬取到的图片 却是二进制数据，</p>
<p> ​    我们通过base64  转换 存入redis数据库中，</p>
<p> ​    Python base64与图片之间的转换<a href="https://blog.csdn.net/qq_34449006/article/details/84312550">https://blog.csdn.net/qq_34449006/article/details/84312550</a></p>
<p> ​    </p>
</li>
</ol>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
<p>​    </p>
]]></content>
      <categories>
        <category>爬虫框架scrapy</category>
        <category>爬虫 分布式</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>爬虫框架scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/05/13/%E5%93%88%E5%BC%97%E6%9B%BC%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>哈弗曼</p>
]]></content>
  </entry>
  <entry>
    <title>微信小程序知识点 总结</title>
    <url>/2021/01/15/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>缓存技术</p>
<p><img src="http://qny.jkraise.top/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1615249714299.png~01style" alt="1615249714299"></p>
<a id="more"></a>
<h2 id="微信小程序知识点-总结"><a href="#微信小程序知识点-总结" class="headerlink" title="微信小程序知识点 总结"></a>微信小程序知识点 总结</h2><p>缓存技术</p>
<p><img src="http://qny.jkraise.top/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1615249714299.png~01style" alt="1615249714299"></p>
<ol>
<li>开搞  按思路来</li>
</ol>
<p><img src="http://qny.jkraise.top/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1615250065955.png~01style" alt="1615250065955"></p>
<p>2，web 与小程序的不同</p>
<p><img src="http://qny.jkraise.top/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1615251158606.png~01style" alt="1615251158606"></p>
<p>3，最后利用 判断时间戳</p>
<p><img src="http://qny.jkraise.top/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9F%A5%E8%AF%86%E7%82%B9.assets/1615251158606.png~01style" alt="1615251240231"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Python 排序算法</title>
    <url>/2021/01/15/%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95sort/</url>
    <content><![CDATA[<p>Python 排序算法</p>
<a id="more"></a>

<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ol>
<li><p>树（节点）， 子节点（孩子） 左节点，右节点</p>
</li>
<li><p>满二叉树    全都是满的</p>
</li>
<li><p>完全二叉树    最后一层可以不满  但集中在左侧</p>
</li>
<li><p>堆  小顶（根）堆    大顶（根）堆</p>
</li>
</ol>
<ul>
<li>在二叉树中，第i层的节点总数不超过2^(i-1)</li>
<li>对于任意一棵二叉树，如果其叶子节点数为n0，而度数为2的节点总数为n2， 则n0=n2+1</li>
<li>具有n个节点的完全二叉树的深度为int(log2n) +1</li>
</ul>
<p><img src="http://qny.jkraise.top/%E6%95%B0%E6%8D%AE%E7%AE%97%E6%B3%95sort.assets/1610506218125.png~01style" alt="1610506218125"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从小到大 排序 那么就把树调整为大根堆</span><br><span class="line"># 从大到小 排序 那么就把树调整为小根堆</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def adjustHeap(li, i, length):</span><br><span class="line">    # 定义左孩子 下标</span><br><span class="line">    j &#x3D; 2 * i + 1  # 左孩子节点位置</span><br><span class="line">    # 把i位置保存下来</span><br><span class="line">    temp &#x3D; li[i]</span><br><span class="line">    # 列表的长度</span><br><span class="line"></span><br><span class="line">    while j &lt; length:</span><br><span class="line">        # 判断右孩子 是否存在 并且右孩子是否比左孩子大</span><br><span class="line">        if j + 1 &lt; length and li[j + 1] &gt; li[j]:</span><br><span class="line">            j &#x3D; j + 1</span><br><span class="line">        if li[j] &gt; temp:</span><br><span class="line">        	# 交换位置</span><br><span class="line">            li[i] &#x3D; li[j]</span><br><span class="line">            # 把i的位置移动到j   对i进行大根堆调整</span><br><span class="line">            i &#x3D; j</span><br><span class="line">            j &#x3D; 2 * i + 1  # 重新计算左孩子的位置</span><br><span class="line"></span><br><span class="line">        else:  # temp 更大 比较结束</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    li[i] &#x3D; temp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def heap_sort(li):</span><br><span class="line">    length &#x3D; len(li)</span><br><span class="line">    # range(4,-1,-1)</span><br><span class="line">    # 从最后一个非叶节点开始 循环构造大根堆</span><br><span class="line">    for i in range(length - 1, -1, -1):</span><br><span class="line">        adjustHeap(li, i, length)</span><br><span class="line"></span><br><span class="line">    for i in range(length - 1, -1, -1):</span><br><span class="line">        li[0], li[i] &#x3D; li[i], li[0]</span><br><span class="line"></span><br><span class="line">        adjustHeap(li, 0, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    lista &#x3D; [22, 15, 18, 17, 14, 2, 12, 1, 23, 10, 33]</span><br><span class="line"></span><br><span class="line">    a &#x3D; int(time.time() * 1000)</span><br><span class="line">    heap_sort(lista)</span><br><span class="line">    b &#x3D; int(time.time() * 1000)</span><br><span class="line">    print(b - a)</span><br><span class="line">    print(&quot;--------------&quot;)</span><br><span class="line">    print(lista)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p> 每次能够排除掉一半的数据，查找的效率非常高，但是局限性比较大。<br>必须是有序序列才可以使用二分查找。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def binary_search(lis,right, left,item):</span><br><span class="line">	# lis 有序列表</span><br><span class="line">	# left 左指针 0</span><br><span class="line">	# right 右指针 len(lis)-1</span><br><span class="line">	# item  查找元素 </span><br><span class="line">    while left &lt;&#x3D;right :  </span><br><span class="line">        mid &#x3D; (right + left) &#x2F;&#x2F;2    # 获取中间位置，数字的索引</span><br><span class="line">        if item &lt; lis[mid]:			#如果查询的数字比中间值小，就去二分之后的左边找</span><br><span class="line">            right &#x3D; mid -1			# 来到左边之后 右边边界 mid -1</span><br><span class="line"></span><br><span class="line">        elif item &gt; lis[mid]:		#如果查询的数字比中间值大，就去二分之后的右边找</span><br><span class="line">            left &#x3D; mid +1			# 来到右边之后 右边边界 mid +1</span><br><span class="line">        else:</span><br><span class="line">            return mid # 返回中间值的下标</span><br><span class="line">	return -1 # 如果 循环结束，左边大于右边 没有找到元素  </span><br><span class="line">lis &#x3D; [11, 32, 51, 21, 42, 9, 5, 6, 7, 8]</span><br><span class="line">    print(lis)</span><br><span class="line">    lis.sort()</span><br><span class="line">    print(lis)    </span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    num &#x3D; int(input(&#39;输入要查找的数：&#39;))</span><br><span class="line">    res &#x3D; binary_search(lis, len(lis)-1,0,num)</span><br><span class="line">    print(res)</span><br><span class="line">    if res &#x3D;&#x3D; -1:</span><br><span class="line">        print(&#39;未找到！&#39;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;找到！&#39;)  </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"># 2 ，递归算法</span><br><span class="line">def binary_search(lis, right, left, item):</span><br><span class="line">    # 结束条件</span><br><span class="line">    if left &gt; right:</span><br><span class="line">        return -1  # 结束递归</span><br><span class="line">    mid &#x3D; (left + right) &#x2F;&#x2F; 2</span><br><span class="line">    if item &lt; lis[mid]:</span><br><span class="line">        right &#x3D; mid - 1</span><br><span class="line">    elif item &gt; lis[mid]:</span><br><span class="line">        left &#x3D; mid + 1</span><br><span class="line"></span><br><span class="line">    else:</span><br><span class="line">        return mid</span><br><span class="line">    return binary_search(lis, right, left, item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lis &#x3D; [11, 32, 51, 21, 42, 9, 5, 6, 7, 8]</span><br><span class="line">print(lis)</span><br><span class="line">lis.sort()</span><br><span class="line">print(lis)</span><br><span class="line"></span><br><span class="line">while 1:</span><br><span class="line">    num &#x3D; int(input(&#39;输入要查找的数：&#39;))</span><br><span class="line">    res &#x3D; binary_search(lis, len(lis) - 1, 0, num)</span><br><span class="line">    print(res)</span><br><span class="line">    if res &#x3D;&#x3D; -1:</span><br><span class="line">        print(&#39;未找到！&#39;)</span><br><span class="line">    else:</span><br><span class="line">        print(&#39;找到！&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_list</span>(<span class="params">list01</span>):</span></span><br><span class="line">	<span class="comment"># list01  一个列表</span></span><br><span class="line">	n = len(list01)</span><br><span class="line">	<span class="comment"># 递归结束条件</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">		<span class="keyword">return</span> list01 </span><br><span class="line"></span><br><span class="line">	<span class="comment"># 取个中间值</span></span><br><span class="line">	mid = n //<span class="number">2</span></span><br><span class="line">	<span class="comment"># 分成左右两个列表 </span></span><br><span class="line">	<span class="comment"># left 采用归并排序后形成新的有序的列表</span></span><br><span class="line">	left_li = merge_list(list01[:mid])</span><br><span class="line">	<span class="comment"># right 采用归并排序后形成新的有序的列表</span></span><br><span class="line">	right_li = merge_list(list01[mid:])</span><br><span class="line">	left_pointer, right_pointer =<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">	ret=[]</span><br><span class="line">	<span class="keyword">while</span> left_pointer &lt; len(left_li) <span class="keyword">and</span> right_pointer &lt; len(right_li):</span><br><span class="line">		<span class="keyword">if</span> left_li[left_pointer] &lt;= right_li[right_pointer]:</span><br><span class="line">			ret.append(left_li[left_pointer])</span><br><span class="line">			left_pointer +=<span class="number">1</span></span><br><span class="line">		<span class="keyword">else</span>:</span><br><span class="line">			ret.append(right_li[right_pointer])</span><br><span class="line">			right_pointer +=<span class="number">1</span></span><br><span class="line">	ret += left_li[left_pointer:]</span><br><span class="line">	ret += right_li[right_pointer:]</span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__mian__&quot;</span>:</span><br><span class="line">    ret = merge_list([<span class="number">12</span>, <span class="number">32321</span>, <span class="number">3211</span>, <span class="number">212</span>, <span class="number">3343</span>, <span class="number">222</span>, <span class="number">112</span>, <span class="number">121</span>])</span><br><span class="line">    print(ret)</span><br></pre></td></tr></table></figure>

<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def insert_sort(mylist):</span><br><span class="line">    for i in range(1,len(mylist)):</span><br><span class="line">        pre &#x3D; i - 1</span><br><span class="line">        current &#x3D; mylist[i]</span><br><span class="line"></span><br><span class="line">        while pre &gt;&#x3D; 0 and mylist[pre] &gt; current:</span><br><span class="line">            mylist[pre + 1] &#x3D; mylist[pre]</span><br><span class="line">            pre -&#x3D; 1</span><br><span class="line">        mylist[pre + 1] &#x3D; current</span><br><span class="line">    return mylist</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    ret &#x3D; insert_sort([12, 2323, 123, 2123, 321, 23, 3232, 1123, 11233])</span><br><span class="line">    print(ret)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="快排排序"><a href="#快排排序" class="headerlink" title="快排排序"></a>快排排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kuaipai</span>(<span class="params">lis,left,right</span>):</span></span><br><span class="line">    <span class="comment"># 递归结束条件</span></span><br><span class="line">    <span class="keyword">if</span> left&gt; right:</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">    i,j = left,right</span><br><span class="line">    <span class="comment"># 定义基准数</span></span><br><span class="line">    base = lis[left]</span><br><span class="line">    <span class="keyword">while</span> j &gt;i:</span><br><span class="line">        <span class="keyword">while</span> lis[j] &gt;= base <span class="keyword">and</span> j &gt;i:</span><br><span class="line">            j -=<span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> lis[i] &lt;= base <span class="keyword">and</span> j &gt;i:</span><br><span class="line">            i +=<span class="number">1</span></span><br><span class="line">        lis[i].lis[j] = lis[j],lis[i]</span><br><span class="line">    lis[left] = lis[i]</span><br><span class="line">    lis[i] = base</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>



































































































]]></content>
      <categories>
        <category>排序算法</category>
        <category>Python排序算法</category>
        <category>数据算法</category>
      </categories>
      <tags>
        <tag>Python排序算法</tag>
        <tag>排序算法</tag>
        <tag>数据算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速部署 Scrapy项目 scrapyd</title>
    <url>/2020/12/25/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd/</url>
    <content><![CDATA[<p>快速部署 Scrapy项目 scrapyd</p>
<a id="more"></a>

<h3 id="快速部署-Scrapy项目-scrapyd"><a href="#快速部署-Scrapy项目-scrapyd" class="headerlink" title="快速部署 Scrapy项目 scrapyd"></a>快速部署 Scrapy项目 scrapyd</h3><p>给服务端 install scrapyd</p>
<ol>
<li><pre><code class="python">
pip install scrapyd  -i https://pypi.tuna.tsinghua.edu.cn/simple
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. 运行</span><br><span class="line"></span><br><span class="line">   &#96;&#96;&#96;python</span><br><span class="line">   scrapyd</span><br></pre></td></tr></table></figure>

![1607472011253]( http://qny.jkraise.top/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd.assets/1607472011253.png~01style)

3. 修改配置项 ， 以便远程访问

使用Ctrl +c 停止 上一步的运行的scrapyd

在要运行scrapyd 命令的路径下，新建文件scrapyd.cnf 文件

输入以下内容

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[scrapyd]</span><br><span class="line"><span class="comment"># 网页和Json服务监听的IP地址，默认为127.0.0.1（只有改成0.0.0.0 才能在别的电脑上能够访问scrapyd运行之后的服务器）</span></span><br><span class="line">bind_address = <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="comment"># 监听的端口，默认为6800</span></span><br><span class="line">http_port   = <span class="number">6800</span></span><br><span class="line"><span class="comment"># 是否打开debug模式，默认为off</span></span><br><span class="line">debug = off</span><br></pre></td></tr></table></figure>

![1607393462452]( http://qny.jkraise.top/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd.assets/1607393462452.png~01style)
</code></pre>
</li>
</ol>
<p>在客户端 install scrapyd-client</p>
<p>​    1. 安装 scrapy-client 命令如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install scrapyd-client  -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置Scrapy 项目</li>
</ol>
<p>​    修改 scrapy.cfg 文件</p>
<p><img src="http://qny.jkraise.top/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd.assets/1607393290604.png~01style" alt="1607393290604">    </p>
<ol start="2">
<li>1 检查配置 </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">scrapyd-deploay -l</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>发布scrapy项目到scrapyd所在的服务器（此时爬虫未运行）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scrapyd-deploy &lt;target&gt; -p &lt;project&gt; --version &lt;version&gt;</span></span><br><span class="line"><span class="comment"># taget : 就是前面配置文件里的deploy后面的的target名字，例如 ubuntu1</span></span><br><span class="line"><span class="comment"># project: 可以随意定义， 建议与 scrapy 爬虫项目名相同</span></span><br><span class="line"><span class="comment"># version: 自定义版本号 不写的话默认为当前时间戳， 一般不写</span></span><br><span class="line">scrapyd-deploy ubuntu<span class="number">-1</span> -p douban</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong></p>
<ul>
<li>爬虫目录下不要放无关的py文件，放无关的py文件会导致发布失败，但是当爬虫发布成功后，会在当前目录生成一个setup.py文件，可以删除掉。 </li>
</ul>
<ol start="4">
<li><p>发送运行爬虫命令</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl http://<span class="number">10.211</span><span class="number">.55</span><span class="number">.5</span>:<span class="number">6800</span>/schedule.json -d project=douban -d spider=top250</span><br></pre></td></tr></table></figure>
</li>
<li><p>停止爬虫</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl http:&#x2F;&#x2F;ip:6800&#x2F;cancel.json -d project&#x3D;项目名 -d job&#x3D;任务的id值</span><br></pre></td></tr></table></figure>

<p> <img src="http://qny.jkraise.top/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd.assets/1607473183127.png~01style" alt="1607473183127"></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">curl http://<span class="number">10.211</span><span class="number">.55</span><span class="number">.5</span>:<span class="number">6800</span>/cancel.json -d project=douban -d job=<span class="number">121</span>cc034388a11ebb1a7001c42d0a249</span><br></pre></td></tr></table></figure>

<p> <img src="http://qny.jkraise.top/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd.assets/1607473256848.png~01style" alt="1607473256848"></p>
</li>
</ol>
<p><strong>注意</strong></p>
<ol>
<li>如果scrapy项目代码，修改了，只需要重新发布到scrapyd所在服务器即可 </li>
<li>如果scrapy项目暂停了，可以再次通过<code>curl</code>的方式发送命令让其“断点续爬”</li>
</ol>
<h3 id="Scrapy项目部署-图形化操作Gerapy"><a href="#Scrapy项目部署-图形化操作Gerapy" class="headerlink" title="Scrapy项目部署-图形化操作Gerapy"></a>Scrapy项目部署-图形化操作Gerapy</h3><p>一，说明</p>
<p>Gerapy 是一款国人开发的爬虫管理软件（有中文界面）是一个管理爬虫项目的可视化工具，把项目部署到管理的操作全部变为交互式，实现批量部署，更方便控制、管理、实时查看结果。</p>
<p>gerapy和scrapyd的关系就是，我们可以通过gerapy中配置scrapyd后，不使用命令，直接通过图形化界面开启爬虫。</p>
<p>二，安装</p>
<ol>
<li><p>命令  (安装在 爬虫代码 上传端)</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install gerapy  -i https:&#x2F;&#x2F;pypi.tuna.tsinghua.edu.cn&#x2F;simple</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试</p>
<p> <img src="http://qny.jkraise.top/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd.assets/1607473256848.png~01style" alt="1607473594851"></p>
</li>
</ol>
<p>三，使用</p>
<ol>
<li><p>创建一个gerapy工作目录</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gerapy init</span><br></pre></td></tr></table></figure>

<p> 生成文件夹，如下</p>
<p> <img src="http://qny.jkraise.top/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd.assets/1607473670346.png~01style" alt="1607473670346"></p>
</li>
<li><p>创建splite 数据库， 存放部署scrapy 项目版本</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gerapy migrate</span><br></pre></td></tr></table></figure>

<p>  创建成功之后，用tree命令，查看当前的文件列表 </p>
</li>
<li><p>创建用户密码</p>
<p> <img src="http://qny.jkraise.top/%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2scrapyd.assets/1607473857487.png~01style" alt="1607473857487"></p>
</li>
<li><p>启动服务</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gerapy runserver</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>爬虫框架scrapy</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>爬虫框架scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>短信验证码</title>
    <url>/2020/10/09/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81/</url>
    <content><![CDATA[<p> 短信验证码</p>
<a id="more"></a>

<p>当今网站，为了防止，机器人非法注册，出现了，图片验证码， 短信验证码，。。。</p>
<p>今天就来讲一下，短信验证码的流程</p>
<p>这里以 <strong>阿里云</strong>为例，很多网站，都提供<strong>短信服务，API,  只需要SDK</strong>， 就可使用，开通服务即可，</p>
<h4 id="短信验证码"><a href="#短信验证码" class="headerlink" title="短信验证码"></a>短信验证码</h4><p>一, 注册并实名制</p>
<p>1.1 创建一个阿里云账号，<a href="https://account.aliyun.com/register/register.htm?spm=a2c4e.11153940.0.0.40e954a1MwMU0J">点击这里</a></p>
<p>1.2 实名认证：<a href="https://account.console.aliyun.com/?spm=a2c4e.11153940.0.0.40e954a1MwMU0J#/auth/home">点击这里</a></p>
<p>1.3 绑定企业支付宝：<a href="https://account.console.aliyun.com/?spm=a2c4e.11153940.0.0.40e954a1MwMU0J#/auth/home">点击绑定企业支付宝</a></p>
<p>二，开通短信服务</p>
<p><img src="http://qny.jkraise.top/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81.assets/1602497737358.png~01style" alt="1602497737358"></p>
<p>2.1 子账户（使用） <a href="https://dysms.console.aliyun.com/dysms.htm?spm=a2c4e.11153940.0.0.40e954a1GnIycK#/account">点击看子账号页面</a></p>
<p><img src="http://qny.jkraise.top/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81.assets/1602497737358.png~01style" alt="1602504639969"></p>
<p>2.2 进入控制台： <a href="https://dysms.console.aliyun.com/dysms.htm?spm=a2c4e.11153940.0.0.40e954a1GnIycK#/account">点击查看控制台</a></p>
<p><img src="http://qny.jkraise.top/%E7%9F%AD%E4%BF%A1%E9%AA%8C%E8%AF%81%E7%A0%81.assets/1602504695477.png~01style" alt="1602504695477"></p>
<p>进行购买短信包</p>
<ol>
<li><p>这里我们用python 为例， copy下来， 放到， demo中， 进行模块封装，方便进行调用，</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐使用 pip 命令，安装阿里云SDK核心库：</span></span><br><span class="line"></span><br><span class="line">pip install aliyun-python-sdk-core</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.client <span class="keyword">import</span> AcsClient</span><br><span class="line"><span class="keyword">from</span> aliyunsdkcore.request <span class="keyword">import</span> CommonRequest</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_aliyun_msg</span>()</span></span><br><span class="line"><span class="function">	&quot;&quot;&quot;</span></span><br><span class="line"><span class="function">	</span></span><br><span class="line"><span class="function">	:</span>param phone_num: 手机号</span><br><span class="line">	:param content: 短信码</span><br><span class="line">	:<span class="keyword">return</span>: </span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    client = AcsClient(&#x27;&lt;accessKeyId&gt;&#x27;, &#x27;&lt;accessSecret&gt;&#x27;, &#x27;cn-hangzhou&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    request = CommonRequest(pthone_num, content)</span></span><br><span class="line"><span class="string">    request.set_accept_format(&#x27;json&#x27;)</span></span><br><span class="line"><span class="string">    request.set_domain(&#x27;dysmsapi.aliyuncs.com&#x27;)</span></span><br><span class="line"><span class="string">    request.set_method(&#x27;POST&#x27;)</span></span><br><span class="line"><span class="string">    request.set_protocol_type(&#x27;https&#x27;) # https | http</span></span><br><span class="line"><span class="string">    request.set_version(&#x27;2017-05-25&#x27;)</span></span><br><span class="line"><span class="string">    request.set_action_name(&#x27;SendSms&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    request.add_query_param(&#x27;RegionId&#x27;, &quot;cn-hangzhou&quot;)</span></span><br><span class="line"><span class="string">    request.add_query_param (&#x27;PhoneNumbers&#x27;, &quot;%s&quot; %phone_num)</span></span><br><span class="line"><span class="string">	request.add_query_param (&#x27;SignName&#x27;, &quot;jk4716138&quot;)</span></span><br><span class="line"><span class="string">	request.add_query_param (&#x27;TemplateCode&#x27;, &quot;SMS_167532197&quot;)</span></span><br><span class="line"><span class="string">	request.add_query_param (&#x27;TemplateParam&#x27;, &quot;&#123;\&quot;code\&quot;:\&quot;%s\&quot;&#125;&quot; %content)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    response = client.do_action(request)</span></span><br><span class="line"><span class="string">    # python2:  print(response) </span></span><br><span class="line"><span class="string">    print(str(response, encoding = &#x27;utf-8&#x27;))</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">if __name__ == &quot;__main__&quot;:</span></span><br><span class="line"><span class="string">    send_aliyun_msg()</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在注册视图中， 我们进行调用，即可，</p>
</li>
<li><p>短信发送，属于，防止机器人非法注册，（短信一条 大约0.045元，自行测试即可）</p>
</li>
</ol>
<h4 id="图片验证码"><a href="#图片验证码" class="headerlink" title="图片验证码"></a>图片验证码</h4><p>七牛云做图床，Python上传图片</p>
<ol>
<li><p>首先需要install 模块</p>
<ol>
<li><pre><code> pip3 install qiniu
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. &#96;&#96;&#96;python </span><br><span class="line">    # -*- coding: utf-8 -*-</span><br><span class="line">    # flake8: noqa</span><br><span class="line">    from qiniu import Auth, put_file, etag, urlsafe_base64_encode</span><br><span class="line">    import qiniu.config</span><br><span class="line">    import sys</span><br><span class="line">    import os</span><br><span class="line">    import time</span><br><span class="line">    import subprocess</span><br><span class="line">    </span><br><span class="line">    #-----------默认配置-----------</span><br><span class="line">    # accessKey和secretkey是七牛的秘钥</span><br><span class="line">    access_key &#x3D; &#39;七牛账号下查找&#39;</span><br><span class="line">    secret_key &#x3D; &#39;七牛账号下查找&#39;</span><br><span class="line">    # 存储空间</span><br><span class="line">    bucket_name &#x3D; &#39;noteimages&#39;</span><br><span class="line">    # 域名</span><br><span class="line">    bucket_url &#x3D; &#39;存储空间的外链域名&#39;</span><br><span class="line">    </span><br><span class="line">    # 格式</span><br><span class="line">    img_suffix &#x3D; [&quot;jpg&quot;, &quot;jpeg&quot;, &quot;png&quot;, &quot;bmp&quot;, &quot;gif&quot;]</span><br><span class="line">    # 本地存放图片地址</span><br><span class="line">    oldPath &#x3D; &#39;&#x2F;Users&#x2F;zwz&#x2F;Desktop&#x2F;md文件&#x2F;mdImage&#39;</span><br><span class="line">    # 修改名字后存放在的新地址</span><br><span class="line">    newPath &#x3D; &#39;&#x2F;Users&#x2F;zwz&#x2F;Desktop&#x2F;md文件&#x2F;mdNewImage&#39;</span><br><span class="line">    # 生成结果文档</span><br><span class="line">    result_file &#x3D; &#39;&#x2F;Users&#x2F;zwz&#x2F;Desktop&#x2F;result_file.txt&#39;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    # 存放链接数组</span><br><span class="line">    dataArr &#x3D; []</span><br><span class="line">    </span><br><span class="line">    def rename(name):</span><br><span class="line">        count &#x3D; 0</span><br><span class="line">        fileList &#x3D; os.listdir(oldPath)# 该文件夹下所有的文件（包括文件夹）</span><br><span class="line">        for files in fileList: #遍历所有的文件</span><br><span class="line">            oldDir &#x3D; os.path.join(oldPath, files) #原来的文件路径</span><br><span class="line">            if os.path.isdir(oldDir): #如果是文件夹就跳过</span><br><span class="line">                continue</span><br><span class="line">            fileName &#x3D; os.path.splitext(files)[0]  #文件名</span><br><span class="line">            fileType &#x3D; os.path.splitext(files)[1]  #文件扩展名</span><br><span class="line">            if fileType &#x3D;&#x3D; &#39;.jpg&#39; or fileType &#x3D;&#x3D; &#39;&#39;:</span><br><span class="line">                fileType &#x3D; &#39;.png&#39;</span><br><span class="line">            timeString &#x3D; time.strftime(&quot;$%Y-%m-%d$&quot;, time.localtime())</span><br><span class="line">            #生成新的文件名字</span><br><span class="line">            dataName &#x3D; name + timeString + str(count) + fileType</span><br><span class="line">    </span><br><span class="line">            newDir &#x3D; os.path.join(newPath, dataName) # 新的文件路径</span><br><span class="line">            os.rename(oldDir, newDir)</span><br><span class="line">            count +&#x3D; 1</span><br><span class="line">            #链接添加到数组</span><br><span class="line">            dataArr.append(upload_data(dataName,newDir))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #上传文件到七牛, 返回链接地址</span><br><span class="line">    def upload_data(newName, localfilePath):</span><br><span class="line">        q &#x3D; Auth(access_key, secret_key)</span><br><span class="line">        # 上传到七牛后保存的文件名</span><br><span class="line">        key &#x3D; newName;</span><br><span class="line">        # 生成上传 Token，可以指定过期时间等</span><br><span class="line">        token &#x3D; q.upload_token(bucket_name, key, 3600)</span><br><span class="line">        # 要上传文件的本地路径</span><br><span class="line">        localfile &#x3D; localfilePath</span><br><span class="line">        ret, info &#x3D; put_file(token, key, localfile)</span><br><span class="line">        return bucket_url + key</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    def crateFile(dataList):</span><br><span class="line">        with open(result_file, &#39;w+&#39;) as f:</span><br><span class="line">            for data in dataList:</span><br><span class="line">                # 如果是图片则生成图片的markdown格式引用</span><br><span class="line">                if os.path.splitext(data)[1][1:] in img_suffix:</span><br><span class="line">                    f.write(&#39;![](&#39;+data+&#39;)&#39;+&#39;\n&#39;)</span><br><span class="line">    </span><br><span class="line">        f.close()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">        </span><br><span class="line">        #生成链接</span><br><span class="line">        rename(input(&#39;请输入md文章标题:  &#39;))</span><br><span class="line">        #写入文件</span><br><span class="line">        crateFile(dataArr)</span><br><span class="line">        #打开文件</span><br><span class="line">        os.system(&#39;open &#39;+ result_file)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>短信验证码</category>
        <category>短信验证码的子目录</category>
      </categories>
      <tags>
        <tag>短信验证码</tag>
        <tag>网站验证方式</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 django project</title>
    <url>/2020/12/25/Django%E5%AE%9E%E6%88%9801/</url>
    <content><![CDATA[<p>实战01 login</p>
<a id="more"></a>

<h3 id="实战01-login"><a href="#实战01-login" class="headerlink" title="实战01 login"></a>实战01 login</h3><h4 id="一，首先进行"><a href="#一，首先进行" class="headerlink" title="一，首先进行"></a>一，首先进行</h4><ol>
<li>项目搭建， </li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mkvirtualenv -p python3 py3_django_bj  <span class="comment"># 创建虚拟环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入虚拟环境后</span></span><br><span class="line">pip3 install django</span><br><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line">mkdir test_django</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>项目创建</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">django-admin startproject test_django . <span class="comment"># 注意这个点</span></span><br><span class="line"><span class="comment"># 创建app子应用</span></span><br><span class="line">python manage.py startapp app  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>设置 时区</p>
<p>在项目的settings文件中，如下所示</p>
</li>
</ol>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/setTime.png~01style"></p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/setTime2.png~01style"></p>
<ol start="4">
<li><h4 id="设计数据模型"><a href="#设计数据模型" class="headerlink" title="设计数据模型"></a>设计数据模型</h4></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    gender = (</span><br><span class="line">        (<span class="string">&#x27;male&#x27;</span>, <span class="string">&quot;男&quot;</span>),</span><br><span class="line">        (<span class="string">&#x27;female&#x27;</span>, <span class="string">&quot;女&quot;</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    name = models.CharField(max_length=<span class="number">128</span>, unique=<span class="literal">True</span>)</span><br><span class="line">    password = models.CharField(max_length=<span class="number">256</span>)</span><br><span class="line">    email = models.EmailField(unique=<span class="literal">True</span>)</span><br><span class="line">    sex = models.CharField(max_length=<span class="number">32</span>, choices=gender, default=<span class="string">&quot;男&quot;</span>)</span><br><span class="line">    c_time = models.DateTimeField(auto_now_add=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        ordering = [<span class="string">&quot;-c_time&quot;</span>]</span><br><span class="line">        verbose_name = <span class="string">&quot;用户&quot;</span></span><br><span class="line">        verbose_name_plural = <span class="string">&quot;用户&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>设置数据库后端</p>
<p>默认是sqlite数据库， </p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Database</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.sqlite3&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: os.path.join(BASE_DIR, <span class="string">&#x27;db.sqlite3&#x27;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MySQL的配置如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;ENGINE&#x27;</span>: <span class="string">&#x27;django.db.backends.mysql&#x27;</span>,   <span class="comment"># 数据库引擎</span></span><br><span class="line">        <span class="string">&#x27;NAME&#x27;</span>: <span class="string">&#x27;mysite&#x27;</span>,  <span class="comment"># 数据库名，先前创建的</span></span><br><span class="line">        <span class="string">&#x27;USER&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,     <span class="comment"># 用户名，可以自己创建用户</span></span><br><span class="line">        <span class="string">&#x27;PASSWORD&#x27;</span>: <span class="string">&#x27;****&#x27;</span>,  <span class="comment"># 密码</span></span><br><span class="line">        <span class="string">&#x27;HOST&#x27;</span>: <span class="string">&#x27;192.168.1.123&#x27;</span>,  <span class="comment"># mysql服务所在的主机ip</span></span><br><span class="line">        <span class="string">&#x27;PORT&#x27;</span>: <span class="string">&#x27;3306&#x27;</span>,         <span class="comment"># mysql服务端口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>注册app</li>
</ol>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/03.png~01style" alt="注册app"></p>
<ol start="7">
<li><p>创建记录和数据表</p>
<p>进入pycharm 的terminal终端， 执行以下命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py makemigrations</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/04.png~01style" alt="model"></p>
<p> Django自动为我们创建了<code>app\migrations\0001_initial.py</code>文件，保存了我们的第一次数据迁移工作，也就是创建了User模型。 </p>
<p>接着执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure>

<h4 id="二-admin后台"><a href="#二-admin后台" class="headerlink" title="二. admin后台"></a>二. admin后台</h4><hr>
<p>在我们开发的初期，没有真实的用户数据，也没有完整的测试环境，为了测试和开发的方便，通常我们会频繁地使用Django给我们提供的Admin后台管理界面，创建测试用例，观察模型效果等等</p>
<ol>
<li><p>因为admin 已经注册了， 所以无需再次注册，</p>
</li>
<li><p>进入app/admin.py 文件， 代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># Register your models here.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line">admin.site.register(models.User)</span><br></pre></td></tr></table></figure>

<p>暂时简单点， 直接注册就好了</p>
</li>
</ol>
<h4 id="创建超级管理员"><a href="#创建超级管理员" class="headerlink" title="创建超级管理员"></a>创建超级管理员</h4><p>Django的admin后台拥有完整的较为安全的用户认证和授权机制，防护等级还算可以。</p>
<p>要进入该后台，需要创建超级管理员，该管理员和我们先前创建的User用户不是一个概念，要注意区别对待。</p>
<p>同样在Pycharm的终端中，执行下面的命令：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python manage.py createsuperuser</span><br></pre></td></tr></table></figure>

<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/05.png~01style"></p>
<h4 id="三，使用Admin后台"><a href="#三，使用Admin后台" class="headerlink" title="三，使用Admin后台"></a>三，使用Admin后台</h4><p>创建好超级管理员后，就可以启动我们的开发服务器了，然后在浏览器中访问<code>http://127.0.0.1:8000/admin/</code>地址，可以看到如下的登录界面：   </p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/06.png~01style" alt="1611027106282"></p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/07.png~01style" alt="1611027127248"></p>
<p>注意，图中下方的<code>认证和授权</code>是admin应用自身的账户管理，上面的app栏目才是我们创建的login应用所对应的User模型。</p>
<p>点击app栏目中的用户链接，进入用户列表界面，发现是空的，因为我们当前没有任何用户。点击右上方的增加用户按钮，我们创建几个测试用户试试：</p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/08.png~01style" alt="1611027421214"></p>
<p> 但是，实际上这里还有点小问题，那就是密码相关。密码不能保存为明文，这个问题我们后面再解决；其次，不可以这么随意的修改和设置密码，为了展示的方便性，我们先这样 </p>
<p>添加了3个用户</p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/09.png~01style" alt="1611027618523"></p>
<p> admin的使用和配置博大精深，但在本实战项目里，我们暂时把它当做一个数据库管理后台使用 </p>
<h4 id="url路由和视图"><a href="#url路由和视图" class="headerlink" title="url路由和视图"></a>url路由和视图</h4><p> 前面我们已经创建好数据模型了，并且在admin后台中添加了一些测试用户。下面我们就要设计好站点的url路由、对应的处理视图函数以及使用的前端模板了。 </p>
<ol>
<li><p>路由设计</p>
<p>我们初步设想需要下面的四个URL：</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>视图</th>
<th>模板</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>/index/</td>
<td>login.views.index</td>
<td>index.html</td>
<td>主页</td>
</tr>
<tr>
<td>/login/</td>
<td>login.views.login</td>
<td>login.html</td>
<td>登录</td>
</tr>
<tr>
<td>/register/</td>
<td>login.views.register</td>
<td>register.html</td>
<td>注册</td>
</tr>
<tr>
<td>/logout/</td>
<td>login.views.logout</td>
<td>无需专门的页面</td>
<td>退出</td>
</tr>
</tbody></table>
<p>重要说明：由于本项目目的是打造一个针对管理系统、应用程序等需求下的可重用的登录/注册app，而不是门户网站、免费博客等无需登录即可访问的网站，所以在url路由、跳转策略和文件结构的设计上都是尽量自成体系。具体访问的策略如下</p>
<ul>
<li>未登录人员，不论是访问index还是login和logout，全部跳转到login界面</li>
<li>已登录人员，访问login会自动跳转到index页面</li>
<li>已登录人员，不允许直接访问register页面，需先logout</li>
<li>登出后，自动跳转到login界面</li>
</ul>
<p>考虑到登录注册系统属于站点的一级功能，为了直观和更易于接受，这里没有采用二级路由的方式，而是在根路由下直接编写路由条目，同样也没有使用反向解析名（name参数）。所以，在重用本app的时候，一定要按照app使用说明，加入相应的url路由。</p>
</li>
</ol>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/10.png~01style" alt="1611028151106"></p>
<h4 id="四，编写-视图函数"><a href="#四，编写-视图函数" class="headerlink" title="四，编写 视图函数"></a>四，编写 视图函数</h4><p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/11.png~01style" alt="1611063774388"></p>
<p><strong>现在我们的工作目录</strong></p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/12.png~01style" alt="1611063822972"></p>
<p><strong>访问主页</strong></p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/13.png~01style" alt="1611063870554"></p>
<p><strong>1.login</strong> <strong>页面编写</strong></p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/14.png~01style" alt="1611064067731"></p>
<p><strong>2. 引入Bootstrap 4</strong></p>
<p>Bootstrap4就是最好的CSS框架之一！</p>
<p>想要在HTML页面中使用Bootstrap4，最方便的方法就是使用国内外的免费CDN（如果app的使用环境不可以使用外部网络，也可以使用内部的CDN，或者静态文件）。</p>
<p>这里推荐BootCDN：<a href="https://www.bootcdn.cn/%EF%BC%8C%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83%E5%BF%AB%EF%BC%8C%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E7%9A%84CDN%E3%80%82">https://www.bootcdn.cn/，速度比较快，有大量的不同版本的CDN。</a></p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/15.png~01style" alt="1611064272802"></p>
<p>jQuery</p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/16.png~01style" alt="1611064538948"></p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/17.png~01style" alt="1611064489803"></p>
<p>五，静态文件的引入</p>
<p> 继续在<code>/login/static/login</code>目录下创建一个css和一个image目录，css中添加我们为登录视图写的css文件，这里是<code>login.cs![17](/17.png)![17](/17.png)s</code>，image目录中，拷贝进来你想要的背景图片，这里是<code>bg.jpg</code>。最终目录结构如下： </p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/18.png~01style" alt="1611065555604"></p>
<p> 主要是引入了login.css文件，注意最开头的<code>&#123;% load static %&#125;</code>，表示我们要加载静态文件。 </p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/19.png~01style" alt="1611065927558"></p>
<p><strong>登录视图</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def login(request):</span><br><span class="line">    if request.method &#x3D;&#x3D; &quot;POST&quot;:</span><br><span class="line">        username &#x3D; request.POST.get(&#39;username&#39;)</span><br><span class="line">        password &#x3D; request.POST.get(&#39;password&#39;)</span><br><span class="line">        print(username, password)</span><br><span class="line">        return redirect(&#39;&#x2F;index&#x2F;&#39;)</span><br><span class="line">    return render(request, &#39;login&#x2F;login.html&#39;)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><p>每个视图函数都至少接收一个参数，并且是第一位置参数，该参数封装了当前请求的所有数据；</p>
</li>
<li><p>通常将第一参数命名为request，当然也可以是别的；</p>
</li>
<li><p><code>request.method</code>中封装了数据请求的方法，如果是“POST”（全大写），将执行if语句的内容，如果不是，直接返回最后的render()结果，也就是正常的登录页面；</p>
</li>
<li><p><code>request.POST</code>封装了所有POST请求中的数据，这是一个字典类型，可以通过get方法获取具体的值。</p>
</li>
<li><p>类似<code>get(&#39;username&#39;)</code>中的键‘username’是HTML模板中表单的input元素里‘name’属性定义的值。所以在编写form表单的时候一定不能忘记添加name属性。</p>
</li>
<li><p>利用print函数在开发环境中验证数据；</p>
</li>
<li><p>利用redirect方法，将页面重定向到index页。</p>
<p>启动服务器，然后在<code>http://127.0.0.1:8000/login/</code>的表单中随便填入用户名和密码，然后点击提交。然而，页面却出现了错误提示，如下图所示： </p>
</li>
</ul>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/20.png~01style" alt="1611066293446"></p>
<p> 解决这个问题的办法其实在Django的Debug错误页面已经给出了，我们需要在前端页面的form表单内添加一个<code>&#123;% csrf_token %&#125;</code>标签： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-login&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/login/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                 &#123;% csrf_token %&#125;</span><br><span class="line">                 <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span>欢迎登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;id_username&quot;</span>&gt;</span>用户名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;username&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;id_username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Username&quot;</span> <span class="attr">autofocus</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;form-group&quot;</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;id_password&quot;</span>&gt;</span>密码：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&#x27;password&#x27;</span> <span class="attr">class</span>=<span class="string">&quot;form-control&quot;</span> <span class="attr">id</span>=<span class="string">&quot;id_password&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;Password&quot;</span> <span class="attr">required</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/register/&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-success &quot;</span> &gt;</span><span class="tag">&lt;<span class="name">ins</span>&gt;</span>新用户注册<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary float-right&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> <strong>数据验证</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> username.strip() <span class="keyword">and</span> password:  <span class="comment"># 确保用户名和密码都不为空      </span></span><br><span class="line">            <span class="comment"># 用户名字符合法性验证</span></span><br><span class="line">            <span class="comment"># 密码长度验证</span></span><br><span class="line">            <span class="comment"># 更多的其它验证.....</span></span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">&#x27;/index/&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>get方法是Python字典类型的内置方法，它能够保证在没有指定键的情况下，返回一个None，从而确保当数据请求中没有username或password键时不会抛出异常；</li>
<li>通过<code>if username and password:</code>确保用户名和密码都不为空；</li>
<li>通过strip方法，将用户名前后无效的空格剪除；</li>
<li>更多的数据验证需要根据实际情况增加，原则是以最低的信任度对待发送过来的数据。</li>
</ul>
<p><strong>账户密码</strong> <strong>验证</strong></p>
<p> 注意其中添加了一句<code>from . import models</code>，导入我们先前编写好的model模型。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        username = request.POST.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> username.strip() <span class="keyword">and</span> password:  <span class="comment"># 确保用户名和密码都不为空</span></span><br><span class="line">            <span class="comment"># 用户名字符合法性验证</span></span><br><span class="line">            <span class="comment"># 密码长度验证</span></span><br><span class="line">            <span class="comment"># 更多的其它验证.....</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                user = models.User.objects.get(name=username)</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> user.password == password:</span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/index/&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>添加提示信息</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message = <span class="string">&#x27;请检查填写的内容！&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> username.strip() <span class="keyword">and</span> password:</span><br><span class="line">            <span class="comment"># 用户名字符合法性验证</span></span><br><span class="line">            <span class="comment"># 密码长度验证</span></span><br><span class="line">            <span class="comment"># 更多的其它验证.....</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                user = models.User.objects.get(name=username)</span><br><span class="line">            <span class="keyword">except</span> :</span><br><span class="line">                message = <span class="string">&#x27;用户不存在！&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>, &#123;<span class="string">&#x27;message&#x27;</span>: message&#125;)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> user.password == password:</span><br><span class="line">                print(username, password)</span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/index/&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                message = <span class="string">&#x27;密码不正确！&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>, &#123;<span class="string">&#x27;message&#x27;</span>: message&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>, &#123;<span class="string">&#x27;message&#x27;</span>: message&#125;)</span><br></pre></td></tr></table></figure>

<p> <strong>说明</strong>： 这里增加了message变量，用于保存提示信息。当有错误信息的时候，将错误信息打包成一个字典，然后作为第三个参数提供给render方法。这个数据字典在渲染模板的时候会传递到模板里供你调用。 </p>
<p> <strong>为了在前端页面显示信息，还需要对<code>login.html</code>进行修改：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form class&#x3D;&quot;form-login&quot; action&#x3D;&quot;&#x2F;login&#x2F;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">                  &#123;% if message %&#125;</span><br><span class="line">                    &lt;div class&#x3D;&quot;alert alert-warning&quot;&gt;&#123;&#123; message &#125;&#125;&lt;&#x2F;div&gt;</span><br><span class="line">                  &#123;% endif %&#125;</span><br><span class="line">                  &#123;% csrf_token %&#125;</span><br><span class="line">                  &lt;h3 class&#x3D;&quot;text-center&quot;&gt;欢迎登录&lt;&#x2F;h3&gt;</span><br><span class="line">                  &lt;div class&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                    &lt;label for&#x3D;&quot;id_username&quot;&gt;用户名：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&#39;username&#39; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;id_username&quot; placeholder&#x3D;&quot;Username&quot; autofocus required&gt;</span><br><span class="line">                  &lt;&#x2F;div&gt;</span><br><span class="line">                  &lt;div class&#x3D;&quot;form-group&quot;&gt;</span><br><span class="line">                    &lt;label for&#x3D;&quot;id_password&quot;&gt;密码：&lt;&#x2F;label&gt;</span><br><span class="line">                    &lt;input type&#x3D;&quot;password&quot; name&#x3D;&#39;password&#39; class&#x3D;&quot;form-control&quot; id&#x3D;&quot;id_password&quot; placeholder&#x3D;&quot;Password&quot; required&gt;</span><br><span class="line">                  &lt;&#x2F;div&gt;</span><br><span class="line">                  &lt;div&gt;</span><br><span class="line">                  &lt;a href&#x3D;&quot;&#x2F;register&#x2F;&quot; class&#x3D;&quot;text-success &quot; &gt;&lt;ins&gt;新用户注册&lt;&#x2F;ins&gt;&lt;&#x2F;a&gt;</span><br><span class="line">                  &lt;button type&#x3D;&quot;submit&quot; class&#x3D;&quot;btn btn-primary float-right&quot;&gt;登录&lt;&#x2F;button&gt;</span><br><span class="line">                  &lt;&#x2F;div&gt;</span><br><span class="line">                &lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p> Django的模板语言<code>&#123;% if xxx %&#125;&#123;% endif %&#125;</code>非常类似Python的if语句，也可以添加<code>&#123;% else %&#125;</code>分句。例子中，通过判断message变量是否为空，也就是是否有错误提示信息，如果有，就显示出来！这里使用了Bootstrap的警示信息类alert，你也可以自定义CSS或者JS。 </p>
<p><img src="http://qny.jkraise.top/Django%E5%AE%9E%E6%88%9801.assets/21.png~01style" alt="1611067107437"></p>
<h4 id="Django表单"><a href="#Django表单" class="headerlink" title="Django表单"></a>Django表单</h4><ol>
<li>创建表单模型</li>
</ol>
<p>在app/创建forms.py 文件进行 表单模型创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserForm</span>(<span class="params">forms.Form</span>):</span></span><br><span class="line">    username = forms.CharField(label=<span class="string">&#x27;用户名&#x27;</span>,max_length=<span class="number">128</span>)</span><br><span class="line">    password = forms.CharField(label=<span class="string">&#x27;用户名&#x27;</span>,max_length=<span class="number">256</span>,widget=forms.PasswordInput)</span><br><span class="line">    </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>顶部要先导入forms模块</li>
<li>所有的表单类都要继承forms.Form类</li>
<li>每个表单字段都有自己的字段类型比如CharField，它们分别对应一种HTML语言中``内的一个input元素。这一点和Django模型系统的设计非常相似。</li>
<li>label参数用于设置``标签</li>
<li><code>max_length</code>限制字段输入的最大长度。它同时起到两个作用，一是在浏览器页面限制用户输入不可超过字符数，二是在后端服务器验证用户输入的长度也不可超过。</li>
<li><code>widget=forms.PasswordInput</code>用于指定该字段在form表单里表现为``，也就是密码输入框。</li>
</ul>
<ol start="2">
<li>修改视图函数</li>
</ol>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;POST&quot;</span>:</span><br><span class="line">        login_form = forms.UserForm(request.POST)</span><br><span class="line">        message = <span class="string">&#x27;请检查填写的内容！&#x27;</span></span><br><span class="line">        <span class="keyword">if</span> login_form.is_valid():</span><br><span class="line">            <span class="comment"># 用户名字符合法性验证</span></span><br><span class="line">            <span class="comment"># 密码长度验证</span></span><br><span class="line">            <span class="comment"># 更多的其它验证.....</span></span><br><span class="line">            username = login_form.cleaned_data.get(<span class="string">&#x27;username&#x27;</span>)</span><br><span class="line">            password = login_form.cleaned_data.get(<span class="string">&#x27;password&#x27;</span>)</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                user = models.User.objects.get(name=username)</span><br><span class="line">            <span class="keyword">except</span> :</span><br><span class="line">                message = <span class="string">&#x27;用户不存在！&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>, locals())</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> user.password == password:</span><br><span class="line">                print(username, password)</span><br><span class="line">                <span class="keyword">return</span> redirect(<span class="string">&#x27;/index/&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                message = <span class="string">&#x27;密码不正确！&#x27;</span></span><br><span class="line">                <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>, locals())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>, locals())</span><br><span class="line">    login_form = forms.UserForm()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;login/login.html&#x27;</span>, locals())</span><br><span class="line">    <span class="comment"># locals()  会自动构造成字典， 不需要在自己去构造， 但是也会传入一些多余的变量数据，造成数据冗余降低效率</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改login页面</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Required meta tags --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上述meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap CSS --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/4.3.1/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% static &#x27;login/css/login.css&#x27; %&#125;&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">&quot;form-login&quot;</span> <span class="attr">action</span>=<span class="string">&quot;/login/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">                  &#123;% if message %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;alert alert-warning&quot;</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                  &#123;% endif %&#125;</span><br><span class="line">                  &#123;% csrf_token %&#125;</span><br><span class="line">                  <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;text-center&quot;</span>&gt;</span>欢迎登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line">                  &#123;&#123; login_form &#125;&#125;</span><br><span class="line"></span><br><span class="line">                  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/register/&quot;</span> <span class="attr">class</span>=<span class="string">&quot;text-success &quot;</span> &gt;</span><span class="tag">&lt;<span class="name">ins</span>&gt;</span>新用户注册<span class="tag">&lt;/<span class="name">ins</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                      <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;btn btn-primary float-right&quot;</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="comment">&lt;!-- /container --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Optional JavaScript --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- jQuery first, then Popper.js, then Bootstrap JS --&gt;</span></span><br><span class="line">    &#123;#    以下三者的引用顺序是固定的#&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/jquery/3.3.1/jquery.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/popper.js/1.15.0/umd/popper.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>​     一个<code>&#123;&#123; login_form &#125;&#125;</code>就直接完成了表单内容的生成工作！<code>login_form</code>这个名称来自你在视图函数中生成的form实例的变量名！ </p>
<p>实际上除了通过<code>&#123;&#123; login_form &#125;&#125;</code>简单地将表单渲染到HTML页面中了，还有下面几种方式：</p>
<ul>
<li><code>&#123;&#123; login_form.as_table &#125;&#125;</code> 将表单渲染成一个表格元素，每个输入框作为一个标签</li>
<li><code>&#123;&#123; login_form.as_p &#125;&#125;</code> 将表单的每个输入框包裹在一个<code>标签内</code></li>
<li>```` 将表单渲染成一个列表元素，每个输入框作为一个``标签</li>
</ul>
]]></content>
      <categories>
        <category>web框架</category>
        <category>Django</category>
        <category>Django项目实战</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Django 项目实战</tag>
        <tag>web基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Django 知识点</title>
    <url>/2021/06/21/Django-knowledge%20point/</url>
    <content><![CDATA[<p>Django 知识点</p>
<a id="more"></a>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p>@<a href="#%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D">1.商业模式介绍</a></p>
<p><a href="#2">2项目知识点</a></p>
<h3 id="商业模式介绍"><a href="#商业模式介绍" class="headerlink" title="商业模式介绍"></a>商业模式介绍</h3><h4 id="1-B2B–企业对企业"><a href="#1-B2B–企业对企业" class="headerlink" title="1. B2B–企业对企业"></a>1. B2B–企业对企业</h4><p> B2B平台是电子商务的一种模式，是英文Business-to-Business的缩写，即商业对商业，或者说是企业间的<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1/98106">电子商务</a>，即企业与企业之间通过<a href="https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186">互联网</a>进行产品、服务及信息的交换。它将企业内部网，通过<a href="https://baike.baidu.com/item/B2B%E7%BD%91%E7%AB%99/7996327">B2B网站</a>与客户紧密结合起来，通过网络的快速反应，为客户提供更好的服务，从而促进企业的业务发展 </p>
<p><strong>案例</strong> 阿里巴巴，</p>
<h4 id="2-C2C–个人对个人"><a href="#2-C2C–个人对个人" class="headerlink" title="2. C2C–个人对个人"></a>2. C2C–个人对个人</h4><p> 通过电子商务网站为买卖用户双方提供一个<a href="https://baike.baidu.com/item/%E5%9C%A8%E7%BA%BF%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0/12751437">在线交易平台</a>，使卖方可以在上面发布待出售的物品的信息，而买方可以从中选择进行购买，同时，为便于<a href="https://baike.baidu.com/item/%E4%B9%B0%E5%8D%96/1177192">买卖</a>双方交易，提供交易所需的一系列配套服务。如：协调市场信息汇集、建立信用评价制度、多种付款方式 </p>
<p><strong>案例</strong> 淘宝，闲鱼，瓜子二手车</p>
<h4 id="3-B2C–企业对个人"><a href="#3-B2C–企业对个人" class="headerlink" title="3. B2C–企业对个人"></a>3. B2C–企业对个人</h4><p>B2C是Business to Customer的缩写，而其中文简称为“商对客”。“商对客”是电子商务的一种模式，也就是通常说的直接面向消费者销售产品和服务商业零售模式·这种形式的电子商务一般以网络零售业为主，主要借助于互联网开展在线销售活动·B2C即企业通过互联网为消费者提供一个新型的购物环境<br>—-网上商店，消费者通过网络在网上购物、网上支付等消费行为。</p>
<p><strong>案例</strong> 唯品会，</p>
<h4 id="4-C2B–个人对企业"><a href="#4-C2B–个人对企业" class="headerlink" title="4.C2B–个人对企业"></a>4.C2B–个人对企业</h4><p>·C2B（Consumer to Business，即消费者到企业），是互联网经济时代新的商业模式。这一模式改变了原有生产者（企业和机构）和消费者的关系，是一种消费者贡献价值（Create Value），企业和机构消费价值（Consume Value）。C2B模式和我们熟知的供需模式（DSM，Demand Supply Model）恰恰相反，真正的C2B应该先有消费者需求产生而后有企业生产，即先有消费者提出需求，后有生产企业按需求组织生产。通常情况为消费者根据自身需求定制产品和价格，或主动参与产品设计、生产和定价，产品、价格等彰显消费者的个性化需求，生产企业进行定制化生产。</p>
<p><strong>案例</strong> 海尔商场，商品宅派</p>
<h3 id="项目知识点"><a href="#项目知识点" class="headerlink" title="项目知识点"></a><a id="2">项目知识点</a></h3><h4 id="live-server实时简易静态服务器"><a href="#live-server实时简易静态服务器" class="headerlink" title="live-server实时简易静态服务器"></a>live-server实时简易静态服务器</h4><p> <strong>Live Server</strong>：一个具有实时加载功能的小型服务器，可以使用它来破解html/css/javascript，但是不能用于部署最终站点。也就是说我们可以在项目中实时用live-server作为一个实时服务器实时查看开发的网页或项目效果。 </p>
<p><strong>安装</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g live-server</span><br></pre></td></tr></table></figure>

<p> 在所在项目目录下，打开命令行工具，输入 live-server，回车就可以了（注意这里默认打开的是index.html）。 </p>
<p>默认端口 8080  可以指定端口 9000</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">live-server --port 9000</span><br></pre></td></tr></table></figure>



<h4 id="ubuntu-设置默认IP地址"><a href="#ubuntu-设置默认IP地址" class="headerlink" title="ubuntu  设置默认IP地址"></a>ubuntu  设置默认IP地址</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设置 wired</span><br><span class="line"></span><br><span class="line">ipv4 </span><br><span class="line">手动设置</span><br><span class="line">A类 10.0.0.0--10.255.255.255</span><br><span class="line">B类 172.16.0.0--172.31.255.255</span><br><span class="line">C类 192.168.0.0--192.168.255.255</span><br><span class="line"></span><br><span class="line">Address 默认为ubuntu 的ip  用ifconfig 查看</span><br><span class="line">Netmask c类 子网掩码 255.255.255.0 </span><br><span class="line">gateway 网关 192.168.17.2</span><br><span class="line">dns 114.114.114.114,119.29.29.29</span><br></pre></td></tr></table></figure>

<p>![1623057663949](Django-knowledge point.assets/1623057663949.png)</p>
<p><a href="https://blog.csdn.net/yuanbinquan/article/details/52963845">详情请到这里面</a></p>
<h4 id="Django自定义文件存储类"><a href="#Django自定义文件存储类" class="headerlink" title="Django自定义文件存储类"></a>Django自定义文件存储类</h4><p><strong>注意</strong></p>
<ul>
<li>必须重写的 <code>_open</code> 方法，<code>_save</code>方法 </li>
<li><code>url</code>方法 用来访问文件</li>
<li><code>exists</code>方法用来判断文件名是否重复，</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">继承Storage必须实现_open()和_save()方法</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FastDFSStorage</span>(<span class="params">Storage</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, client_path=None, base_url=None</span>):</span></span><br><span class="line">        <span class="comment"># fastDFS的客户端配置文件路径</span></span><br><span class="line">        self.client_path = client_path <span class="keyword">or</span> settings.FDFS_CLIENT_CONF</span><br><span class="line">        <span class="comment"># storage服务器ip:端口</span></span><br><span class="line">        self.base_url = base_url <span class="keyword">or</span> settings.FDFS_BASE_URL</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_open</span>(<span class="params">self, name, mode=<span class="string">&#x27;rb&#x27;</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        用来打开文件的,但是我们自定义文件存储系统的目的是为了实现存储到远程的FastDFS服务器,不需要打开文件,所以此方重写后什么也不做pass</span></span><br><span class="line"><span class="string">        :param name: 要打开的文件名</span></span><br><span class="line"><span class="string">        :param mode: 打开文件的模式  read bytes</span></span><br><span class="line"><span class="string">        :return: None</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_save</span>(<span class="params">self, name, content</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        文件存储时什么调用此方法,但是此方法默认是向本地存储,在此方法做实现文件存储到远程的FastDFS服务器</span></span><br><span class="line"><span class="string">        :param name: 要上传的文件名</span></span><br><span class="line"><span class="string">        :param content: 以rb模式打开的文件对象 将来通过content.read() 就可以读取到文件的二进制数据</span></span><br><span class="line"><span class="string">        :return: file_id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 1.创建FastDFS 客户端</span></span><br><span class="line">        <span class="comment"># client = Fdfs_client(&#x27;meiduo_mall/utils/fastdfs/client.conf&#x27;)</span></span><br><span class="line">        <span class="comment"># client = Fdfs_client(settings.FDFS_CLIENT_CONF)</span></span><br><span class="line">        client = Fdfs_client(self.client_path)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.通过客户端调用上传文件的方法上传文件到fastDFS服务器</span></span><br><span class="line">        <span class="comment"># client.upload_by_filename(&#x27;要写上传文件的绝对路径&#x27;) 只能通过文件绝对路径进行上传  此方式上传的文件会有后缀</span></span><br><span class="line">        <span class="comment"># upload_by_buffer 可以通过文件二进制数据进行上传  上传后的文件没有后缀</span></span><br><span class="line">        ret = client.upload_by_buffer(content.read())</span><br><span class="line">        <span class="comment"># 3.判断文件是否上传成功</span></span><br><span class="line">        <span class="keyword">if</span> ret.get(<span class="string">&#x27;Status&#x27;</span>) != <span class="string">&#x27;Upload successed.&#x27;</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Upload file failed&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.1 获取file_id</span></span><br><span class="line">        file_id = ret.get(<span class="string">&#x27;Remote file_id&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4.返回file_id</span></span><br><span class="line">        <span class="keyword">return</span> file_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exists</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当要进行上传时都调用此方法判断文件是否已上传,如果没有上传才会调用save方法进行上传</span></span><br><span class="line"><span class="string">        :param name: 要上传的文件名</span></span><br><span class="line"><span class="string">        :return: True(表示文件已存在,不需要上传)  False(文件不存在,需要上传)</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">url</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        当要访问图片时,就会调用此方法获取图片文件的绝对路径</span></span><br><span class="line"><span class="string">        :param name: 要访问图片的file_id</span></span><br><span class="line"><span class="string">        :return: 完整的图片访问路径: storage_server IP:8888 + file_id</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># return &#x27;http://xxx.xxx.xxx.xx:8888/&#x27; + name</span></span><br><span class="line">        <span class="comment"># return settings.FDFS_BASE_URL + name</span></span><br><span class="line">        <span class="keyword">return</span> self.base_url + name</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在Django中setting文件设置三个变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 指定Django使用的文件存储类 ，上面编写的py文件的路径</span><br><span class="line">DEFAULT_FILE_STORAGE &#x3D; &#39;utils.fdfs.storage.FastDFSStorage&#39;</span><br><span class="line"># 设置fdfs使用的client.conf文件路径 ，变量名自己取，与上面的py文件一致</span><br><span class="line">FDFS_CLIENT_CONF &#x3D; &#39;.&#x2F;utils&#x2F;fdfs&#x2F;client.conf&#39;</span><br><span class="line"># 设置fdfs存储服务器ngibx的ip和端口号，变量名自己取，与上面的py文件一致</span><br><span class="line">FDFS_URL &#x3D; &#39;http:&#x2F;&#x2F;xxx.xxx.xxx.xx:8888&#x2F;&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p><a href="https://docs.djangoproject.com/zh-hans/2.2/howto/custom-file-storage/">具体见官方文档</a> <a href="https://docs.djangoproject.com/zh-hans/2.2/howto/custom-file-storage/">https://docs.djangoproject.com/zh-hans/2.2/howto/custom-file-storage/</a></p>
</li>
<li></li>
</ul>
<h4 id="CKEditor-富文本编辑器"><a href="#CKEditor-富文本编辑器" class="headerlink" title="CKEditor 富文本编辑器"></a>CKEditor 富文本编辑器</h4><ul>
<li><p>安装<code>pip install django-ckeditor</code></p>
</li>
<li><p>注册应用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS &#x3D; [</span><br><span class="line">	......</span><br><span class="line">	&#39;ckeditor&#39;,  # 富⽂文本编辑器器</span><br><span class="line">	&#39;ckeditor_uploader&#39;,  # 富⽂文本编辑器器上传图⽚片模块</span><br><span class="line">	......</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
<li><p>加载配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 富⽂文本编辑器器ckeditor配置</span><br><span class="line">CKEDITOR_CONFIGS &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;toolbar&#39;: &#39;full&#39;,  # ⼯工具条功能</span><br><span class="line">        &#39;height&#39;: 300,  # 编辑器器⾼高度        </span><br><span class="line">        &#39;width&#39;: 300,  # 编辑器器宽</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">CKEDITOR_UPLOAD_PATH &#x3D; &#39;&#39;  # 上传图⽚片保存路路径，使⽤用了了FastDFS，所以此处设为&#39;&#39;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册总路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re_path(r&#39;^ckeditor&#x2F;&#39;, include(&#39;ckeditor_uploader.urls&#39;)),</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>模型类补充富⽂文本字段 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">desc_detail &#x3D; RichTextUploadingField(default&#x3D;&#39;&#39;, verbose_name&#x3D;&#39;详细介绍&#39;)</span><br><span class="line">  desc_pack &#x3D; RichTextField(default&#x3D;&#39;&#39;, verbose_name&#x3D;&#39;包装信息&#39;)</span><br><span class="line">  desc_service &#x3D; RichTextUploadingField(default&#x3D;&#39;&#39;, verbose_name&#x3D;&#39;售后服务&#39;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>修复bug适配FastDFS </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if len(str(saved_path).split(&#39;.&#39;)) &gt; 1:</span><br><span class="line">           if(str(saved_path).split(&#39;.&#39;)[1].lower() !&#x3D; &#39;gif&#39;): self._create_thumbnail_if_needed(backend, saved_path)</span><br><span class="line">  </span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="搜索引擎-全文检索方案Elasticsearch"><a href="#搜索引擎-全文检索方案Elasticsearch" class="headerlink" title="搜索引擎(全文检索方案Elasticsearch)"></a>搜索引擎(全文检索方案Elasticsearch)</h4><blockquote>
<p><strong>实现全文检索的搜索引擎，首选的是</strong><code>Elasticsearch</code><strong>。</strong></p>
</blockquote>
<ul>
<li><a href="https://www.elastic.co/">Elasticsearch</a>是用 Java 实现的，开源的搜索引擎。</li>
<li>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github等都采用它。</li>
<li>Elasticsearch 的底层是开源库<a href="https://lucene.apache.org/">Lucene</a> 。但是，没法直接使用 Lucene，必须自己写代码去调用它的接口。</li>
</ul>
<blockquote>
<p><strong>分词说明</strong></p>
</blockquote>
<ul>
<li><p>搜索引擎在对数据构建索引时，需要进行分词处理。</p>
</li>
<li><p>分词是指将一句话拆解成<strong>多个单字</strong>或<strong>词</strong>，这些字或词便是这句话的关键词。</p>
</li>
<li><p>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是中国人</span><br></pre></td></tr></table></figure>

<ul>
<li>分词后：<code>我</code>、<code>是</code>、<code>中</code>、<code>国</code>、<code>人</code>、<code>中国</code>等等都可以是这句话的关键字。</li>
</ul>
</li>
<li><p>Elasticsearch 不支持对中文进行分词建立索引，需要配合扩展<code>elasticsearch-analysis-ik</code>来实现中文分词处理。</p>
</li>
</ul>
<ol>
<li><h3 id="使用Docker安装Elasticsearch"><a href="#使用Docker安装Elasticsearch" class="headerlink" title="使用Docker安装Elasticsearch"></a>使用Docker安装Elasticsearch</h3><blockquote>
<p><strong>1.获取Elasticsearch-ik镜像</strong></p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从仓库拉取镜像</span></span><br><span class="line">$ sudo docker image pull delron/elasticsearch-ik:<span class="number">2.4</span><span class="number">.6</span><span class="number">-1.0</span></span><br><span class="line"><span class="comment"># 本地镜像</span></span><br><span class="line">$ sudo docker load -i elasticsearch-ik<span class="number">-2.4</span><span class="number">.6</span>_docker.tar</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>2.配置Elasticsearch-ik</strong> </p>
</blockquote>
<ul>
<li><p><code>elasticsearc-2.4.6</code>目录拷贝到<code>home</code>目录下 </p>
</li>
<li><p>修改<code>/home/ubuntu/Desktop/elasticsearc-2.4.6/config/elasticsearch.yml</code>第54行。</p>
</li>
<li><p>更改ip地址为本机真实ip地址。</p>
</li>
</ul>
<blockquote>
<p><strong>3.使用Docker运行Elasticsearch-ik</strong></p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">sudo docker run -dti --name=elasticsearch --network=host -v /home/ubuntu/Desktop/elasticsearch<span class="number">-2.4</span><span class="number">.6</span>/config:/us</span><br></pre></td></tr></table></figure>

<p>![1622039303627](Django-knowledge point.assets/1622039303627.png)</p>
</li>
<li><h3 id="Haystack介绍和安装配置"><a href="#Haystack介绍和安装配置" class="headerlink" title="Haystack介绍和安装配置"></a>Haystack介绍和安装配置</h3><blockquote>
<p><strong>1.Haystack介绍</strong></p>
</blockquote>
<ul>
<li><p>Haystack </p>
<p>是在Django中对接搜索引擎的框架，搭建了用户和搜索引擎之间的沟通桥梁。</p>
<ul>
<li>我们在Django中可以通过使用 Haystack 来调用 Elasticsearch 搜索引擎。</li>
</ul>
</li>
<li><p>Haystack 可以在不修改代码的情况下使用不同的搜索后端（比如<code>Elasticsearch</code>、<code>Whoosh</code>、<code>Solr</code>等等）。</p>
</li>
</ul>
<blockquote>
<p><strong>2.Haystack安装</strong></p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">$ pip install django-haystack</span><br><span class="line">$ pip install elasticsearch==<span class="number">2.4</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>3.Haystack注册应用和路由</strong></p>
</blockquote>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;haystack&#x27;</span>, <span class="comment"># 全文检索</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>4.在setting中配置Haystack</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Haystack</span><br><span class="line">HAYSTACK_CONNECTIONS &#x3D; &#123;</span><br><span class="line">    &#39;default&#39;: &#123;</span><br><span class="line">        &#39;ENGINE&#39;: &#39;haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine&#39;,</span><br><span class="line">        &#39;URL&#39;: &#39;http:&#x2F;&#x2F;192.168.17.132:9200&#x2F;&#39;, # Elasticsearch服务器ip地址，端口号固定为9200</span><br><span class="line">        &#39;INDEX_NAME&#39;: &#39;meiduo_mall&#39;, # Elasticsearch建立的索引库的名称</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 当添加、修改、删除数据时，自动生成索引</span><br><span class="line"># HAYSTACK_SIGNAL_PROCESSOR &#x3D; &#39;haystack.signals.RealtimeSignalProcessor&#39;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h4 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h4><ul>
<li>为了，提升响应速度，提高用户体验，将页面做成静态化，放到静态服务器上运行，</li>
<li>与用户相关的不能做静态化处理，用局部刷新来获取 用户信息，购物车信息，</li>
</ul>
<ol>
<li>首页index_html， 用crontab 来定时生成</li>
<li>静态商品详情页面</li>
</ol>
<h4 id="购物车"><a href="#购物车" class="headerlink" title="购物车"></a>购物车</h4><ul>
<li>购物车存储方法<ul>
<li>用户选择 2个<code>huaweip40</code>添加到购物车中，状态为勾选</li>
</ul>
</li>
<li>一条完整的购物车记录包括了<code>用户</code>,<code>商品</code>,<code>数量</code>，<code>勾选状态</code></li>
<li><strong>存储数据</strong> ：<code>user_id</code>，<code>sku_id</code>，<code>count</code>，<code>selected</code></li>
</ul>
<p><strong>存储 说明</strong></p>
<ol>
<li>购物车数据量小， 结构简单，但是更新频繁，所以我们选择内存型数据库Redis</li>
</ol>
<p><strong>这里，允许用户不登录，也能添加到购物车，利用浏览器的cookie 存储</strong></p>
<ol>
<li><p>密文存储  </p>
<ul>
<li>解决方案：<code>pickle模块</code>和<code>base64模块</code></li>
</ul>
<p>pickle模块使用：</p>
<ul>
<li><code>pickle.dumps()</code>将Python数据序列化为bytes类型数据。</li>
<li><code>pickle.loads()</code>将bytes类型数据反序列化为python数据。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import pickle</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; dict &#x3D; &#123;&#39;1&#39;: &#123;&#39;count&#39;: 10, &#39;selected&#39;: True&#125;, &#39;2&#39;: &#123;&#39;count&#39;: 20, &#39;selected&#39;: False&#125;&#125;</span><br><span class="line">&gt;&gt;&gt; ret &#x3D; pickle.dumps(dict)</span><br><span class="line">&gt;&gt;&gt; ret</span><br><span class="line">b&#39;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01&#125;q\x02(X\x05\x00\x00\x00countq\x03K\nX\x08\x00\x00\x00selectedq\x04\x88uX\x01\x00\x00\x002q\x05&#125;q\x06(h\x03K\x14h\x04\x89uu.&#39;</span><br><span class="line">&gt;&gt;&gt; pickle.loads(ret)</span><br><span class="line">&#123;&#39;1&#39;: &#123;&#39;count&#39;: 10, &#39;selected&#39;: True&#125;, &#39;2&#39;: &#123;&#39;count&#39;: 20, &#39;selected&#39;: False&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>base64模块是Python的标准模块，可以对bytes类型数据进行编码，并得到bytes类型的密文数据。</li>
<li>base64模块使用：<ul>
<li><code>base64.b64encode()</code>将bytes类型数据进行base64编码，返回编码后的bytes类型数据。</li>
<li><code>base64.b64deocde()</code>将base64编码后的bytes类型数据进行解码，返回解码后的bytes类型数据。</li>
</ul>
</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> base64</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret</span><br><span class="line"><span class="string">b&#x27;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01&#125;q\x02(X\x05\x00\x00\x00countq\x03K\nX\x08\x00\x00\x00selectedq\x04\x88uX\x01\x00\x00\x002q\x05&#125;q\x06(h\x03K\x14h\x04\x89uu.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = base64.b64encode(ret)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="string">b&#x27;gAN9cQAoWAEAAAAxcQF9cQIoWAUAAABjb3VudHEDSwpYCAAAAHNlbGVjdGVkcQSIdVgBAAAAMnEFfXEGKGgDSxRoBIl1dS4=&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>base64.b64decode(b)</span><br><span class="line"><span class="string">b&#x27;\x80\x03&#125;q\x00(X\x01\x00\x00\x001q\x01&#125;q\x02(X\x05\x00\x00\x00countq\x03K\nX\x08\x00\x00\x00selectedq\x04\x88uX\x01\x00\x00\x002q\x05&#125;q\x06(h\x03K\x14h\x04\x89uu.&#x27;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="ubuntu-网卡，有时缺少-ens33"><a href="#ubuntu-网卡，有时缺少-ens33" class="headerlink" title="ubuntu 网卡，有时缺少 ens33"></a>ubuntu 网卡，有时缺少 ens33</h4><p><strong>解决方法</strong>  </p>
<p> 让他自动寻址，分别输入，就可以ping通了： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xx@ubuntu:~&#x2F;Desktop$ sudo ifconfig ens33 up</span><br><span class="line">xx@ubuntu:~&#x2F;Desktop$ sudo dhclient ens33</span><br><span class="line">xx@ubuntu:~&#x2F;Desktop$ sudo ifconfig ens33</span><br></pre></td></tr></table></figure>

<p>参考 <a href="https://blog.csdn.net/DrunkMozart/article/details/106172583">Ubuntu18.04解决网卡失效的问题</a></p>
<h4 id="解决-Win10-与-Ubuntu16-04-之间实现粘贴复制"><a href="#解决-Win10-与-Ubuntu16-04-之间实现粘贴复制" class="headerlink" title="解决 Win10 与 Ubuntu16.04 之间实现粘贴复制"></a>解决 Win10 与 Ubuntu16.04 之间实现粘贴复制</h4><p> <strong>Ctrl+C,Ctrl+Shift+V</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install open-vm-tools</span><br><span class="line">sudo apt install open-vm-tools-desktop</span><br><span class="line"># 重启</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h5 id="ubuntu安装-网络相关的包-apt-install-netscript"><a href="#ubuntu安装-网络相关的包-apt-install-netscript" class="headerlink" title="ubuntu安装 网络相关的包 apt install netscript"></a>ubuntu安装 网络相关的包 <code>apt install netscript</code></h5><h4 id="非幂等-amp-幂等"><a href="#非幂等-amp-幂等" class="headerlink" title="非幂等&amp;幂等"></a>非幂等&amp;幂等</h4><ol>
<li><p>概念</p>
<ol>
<li>非幂等<ol>
<li>如果后端处理理结果对于这些请求的最终结果不不同，跟<code>请求次数相关</code>，则称接⼝口⾮非幂等 </li>
</ol>
</li>
<li>幂等<ol>
<li>对于同⼀一个接⼝口，进⾏行行多次相同的请求，如果后端处理理结果对于这些请求都是相同的，则称接⼝口是幂等的 </li>
</ol>
</li>
</ol>
</li>
<li><p>场景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PUT&#x2F;cart&#x2F;</span><br><span class="line">count 商品数量 原始值 10</span><br><span class="line"></span><br><span class="line">方式1 count 表示 商品数量 +1  --&gt;后端执行加1操作，&#x3D;&#x3D;&#x3D;&gt;非幂等</span><br><span class="line">PUT &#x2F;cart&#x2F; count&#x3D;1 --&gt; 11</span><br><span class="line">PUT &#x2F;cart&#x2F; count&#x3D;1 --&gt; 12</span><br><span class="line">PUT &#x2F;cart&#x2F; count&#x3D;1 --&gt; 13</span><br><span class="line"></span><br><span class="line">方式1 count 表示 修改之后的结果  --&gt;后端执行覆盖原有值，&#x3D;&#x3D;&#x3D;&gt;幂等</span><br><span class="line">PUT &#x2F;cart&#x2F; count&#x3D;1 --&gt; 1</span><br><span class="line">PUT &#x2F;cart&#x2F; count&#x3D;1 --&gt; 1</span><br><span class="line">PUT &#x2F;cart&#x2F; count&#x3D;13 --&gt; 13</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Django-事务的使用"><a href="#Django-事务的使用" class="headerlink" title="Django 事务的使用"></a>Django 事务的使用</h4><blockquote>
<p><strong>1.Django中事务的使用方案</strong></p>
</blockquote>
<ul>
<li>在Django中可以通过<code>django.db.transaction模块</code>提供的<code>atomic</code>来定义一个事务。</li>
</ul>
<p><code>atomic</code>提供两种方案实现事务：</p>
<p>装饰器用法：</p>
<ul>
<li><pre><code class="py">from django.db import transaction

@transaction.atomic
def viewfunc(request):
  # 这些代码会在一个事务中执行
  ......
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">with语句用法：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;py</span><br><span class="line">from django.db import transaction</span><br><span class="line"></span><br><span class="line">def viewfunc(request):</span><br><span class="line">  # 这部分代码不在事务中，会被Django自动提交</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line">  with transaction.atomic():</span><br><span class="line">      # 这部分代码会在事务中执行</span><br><span class="line">      ......</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p><strong>2.事务方案的选择：</strong></p>
</blockquote>
<ul>
<li><strong>装饰器用法：</strong> 整个视图中所有MySQL数据库的操作都看做一个事务，范围太大，不够灵活。而且无法直接作用于类视图。</li>
<li><strong>with语句用法：</strong> 可以灵活的有选择性的把某些MySQL数据库的操作看做一个事务。而且不用关心视图的类型。</li>
<li>具体情况具体分析</li>
</ul>
<blockquote>
<p><strong>3.事务中的保存点：</strong></p>
</blockquote>
<ul>
<li>在Django中，还提供了保存点的支持，可以在事务中创建保存点来记录数据的特定状态，数据库出现错误时，可以回滚到数据保存点的状态。</li>
</ul>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> transaction</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建保存点</span></span><br><span class="line">save_id = transaction.savepoint()  </span><br><span class="line"><span class="comment"># 回滚到保存点</span></span><br><span class="line">transaction.savepoint_rollback(save_id)</span><br><span class="line"><span class="comment"># 提交从保存点到当前状态的所有数据库事务操作</span></span><br><span class="line">transaction.savepoint_commit(save_id)</span><br></pre></td></tr></table></figure>

<h4 id="使用乐观锁并发下单"><a href="#使用乐观锁并发下单" class="headerlink" title="使用乐观锁并发下单"></a>使用乐观锁并发下单</h4><blockquote>
<p>原因</p>
</blockquote>
<ul>
<li>在多个用户同时发起对同一个商品的下单请求时，先查询商品库存，再修改商品库存，会出现资源竞争问题，导致库存的最终结果出现异常。</li>
</ul>
<p><strong>注意</strong> 使用乐观锁的时候，如果一个事务修改了库存并提交了事务，那其他的事务应该可以读取到修改后的数据值，所以不能使用可重复读的隔离级别，应该修改为读取已提交（Read committed）</p>
<h4 id="MySQL事务隔离级别"><a href="#MySQL事务隔离级别" class="headerlink" title="MySQL事务隔离级别"></a>MySQL事务隔离级别</h4><ul>
<li>事务隔离级别指的是在处理同一个数据的多个事务中，一个事务修改数据后，其他事务何时能看到修改后的结果。</li>
<li>MySQL数据库事务隔离级别主要有四种：<ul>
<li><code>Serializable</code>：串行化，一个事务一个事务的执行。</li>
<li><code>Repeatable read</code>：可重复读，无论其他事务是否修改并提交了数据，在这个事务中看到的数据值始终不受其他事务影响。</li>
<li><code>Read committed</code>：读取已提交，其他事务提交了对数据的修改后，本事务就能读取到修改后的数据值。</li>
<li><code>Read uncommitted</code>：读取未提交，其他事务只要修改了数据，即使未提交，本事务也能看到修改后的数据值。</li>
<li>MySQL数据库默认使用可重复读（ Repeatable read）。</li>
</ul>
</li>
<li>使用乐观锁的时候，如果一个事务修改了库存并提交了事务，那其他的事务应该可以读取到修改后的数据值，所以不能使用可重复读的隔离级别，应该修改为读取已提交（Read committed）。</li>
<li>修改方式：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf</span><br><span class="line"></span><br><span class="line">修改完成之后重启</span><br><span class="line">sudo service mysql restart</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transaction-isolation&#x3D;READ-COMMITTED</span><br></pre></td></tr></table></figure>

<h3 id="Django-接入-支付-支付宝为例"><a href="#Django-接入-支付-支付宝为例" class="headerlink" title="Django 接入 支付(支付宝为例)"></a>Django 接入 支付(支付宝为例)</h3><blockquote>
<p><strong>支付宝开放平台入口</strong></p>
</blockquote>
<ul>
<li><a href="https://open.alipay.com/platform/home.htm">https://open.alipay.com/platform/home.htm</a></li>
</ul>
<p><strong>登录 账号</strong></p>
<p><strong>控制台</strong></p>
<p>创建应用</p>
<p>![image-20210608220332914](Django-knowledge point.assets/image-20210608220332914.png)</p>
<h5 id="开发服务-测试"><a href="#开发服务-测试" class="headerlink" title="开发服务-测试"></a>开发服务-测试</h5><p><strong>沙箱环境</strong></p>
<p>![image-20210608220404402](Django-knowledge point.assets/image-20210608220404402.png)</p>
<blockquote>
<p><strong>沙箱环境</strong></p>
<p><strong>支付宝提供给开发者的模拟支付的环境。跟真实环境是分开的。</strong></p>
</blockquote>
<ul>
<li>沙箱应用：<a href="https://openhome.alipay.com/platform/appDaily.htm?tab=info">https://openhome.alipay.com/platform/appDaily.htm?tab=info</a></li>
</ul>
<p>![1623247171683](Django-knowledge point.assets/1623247171683.png)</p>
<p>![1623247333771](Django-knowledge point.assets/1623247333771.png)</p>
<h5 id="支付宝开发文档"><a href="#支付宝开发文档" class="headerlink" title="支付宝开发文档"></a>支付宝开发文档</h5><ul>
<li><p>文档主页： <a href="https://openhome.alipay.com/developmentDocument.htm">https://openhome.alipay.com/developmentDocument.htm</a></p>
</li>
<li><p>电脑网站支付产品介绍： <a href="https://docs.open.alipay.com/270">https://docs.open.alipay.com/270</a></p>
</li>
<li><p>电脑网站支付快速接入： <a href="https://docs.open.alipay.com/270/105899/">https://docs.open.alipay.com/270/105899/</a></p>
</li>
<li><p>API列表： <a href="https://docs.open.alipay.com/270/105900/">https://docs.open.alipay.com/270/105900/</a></p>
</li>
<li><p>SDK文档： <a href="https://docs.open.alipay.com/270/106291/">https://docs.open.alipay.com/270/106291/</a></p>
</li>
<li><p>Python支付宝SDK： 这里使用第三方编写，调用简洁</p>
</li>
</ul>
<p>  <a href="https://github.com/fzlee/alipay/blob/master/README.zh-hans.md">https://github.com/fzlee/alipay/blob/master/README.zh-hans.md</a></p>
<ul>
<li>SDK安装： <code>pip install python-alipay-sdk --upgrade</code></li>
</ul>
<h3 id="配置RSA2公私钥"><a href="#配置RSA2公私钥" class="headerlink" title="配置RSA2公私钥"></a>配置RSA2公私钥</h3><p><strong>生成项目公钥</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ openssl</span><br><span class="line">$ OpenSSL&gt; genrsa -out app_private_key.pem 2048  # 制作私钥RSA2</span><br><span class="line">$ OpenSSL&gt; rsa -in app_private_key.pem -pubout -out app_public_key.pem # 导出公钥</span><br><span class="line"></span><br><span class="line">$ OpenSSL&gt; exit</span><br></pre></td></tr></table></figure>



<h5 id="调用时注意"><a href="#调用时注意" class="headerlink" title="调用时注意"></a>调用时注意</h5><p><code>notify_url=&quot; &quot;,</code> 此参数一定要写，<code>Str类型</code></p>
<pre><code>   # 生成登录支付宝连接
   order_string = alipay.api_alipay_trade_page_pay(
        out_trade_no=order_id,
        total_amount=str(order.total_amount),
        subject=&quot;美多商城%s&quot; % order_id,
        return_url=settings.ALIPAY_RETURN_URL,
        notify_url=&quot; &quot;,</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app_private_key_string &#x3D; open(settings.APP_PRIVATE_KEY_PATH).read()</span><br><span class="line">        alipay_public_key_string &#x3D; open(settings.ALIPAY_PUBLIC_KEY_PATH).read()</span><br><span class="line">        # 创建支付宝对象</span><br><span class="line">        alipay &#x3D; AliPay(</span><br><span class="line">            appid&#x3D;settings.ALIPAY_APPID,</span><br><span class="line">            app_notify_url&#x3D;None,  # 默认回调url</span><br><span class="line">            app_private_key_string&#x3D;app_private_key_string,</span><br><span class="line">            # 支付宝的公钥，验证支付宝回传消息使用，不是你自己的公钥，</span><br><span class="line">            alipay_public_key_string&#x3D;alipay_public_key_string,</span><br><span class="line">            sign_type&#x3D;&#39;RSA2&#39;,</span><br><span class="line">            debug&#x3D;True</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        print(&quot;打印参数》》》》》&quot;)</span><br><span class="line"></span><br><span class="line">        print(type(settings.ALIPAY_RETURN_URL))</span><br><span class="line">        print(&quot;执行》》》》》》》&quot;)</span><br><span class="line">        # 生成登录支付宝连接</span><br><span class="line">        order_string &#x3D; alipay.api_alipay_trade_page_pay(</span><br><span class="line">            out_trade_no&#x3D;order_id,</span><br><span class="line">            total_amount&#x3D;str(order.total_amount),</span><br><span class="line">            subject&#x3D;&quot;美多商城%s&quot; % order_id,</span><br><span class="line">            return_url&#x3D;settings.ALIPAY_RETURN_URL,</span><br><span class="line">            notify_url&#x3D;&quot; &quot;,</span><br><span class="line">        )</span><br><span class="line">		</span><br><span class="line">		# 生成登录支付宝连接</span><br><span class="line">        # 3.0 接口方法</span><br><span class="line">        order_string &#x3D; alipay.client_api(</span><br><span class="line">            &quot;alipay.trade.page.pay&quot;,</span><br><span class="line">            biz_content&#x3D;&#123;</span><br><span class="line">                &quot;subject&quot;: &quot;美多商城%s&quot; % order_id,</span><br><span class="line">                &quot;out_trade_no&quot;: order_id,</span><br><span class="line">                &quot;total_amount&quot;: str(order.total_amount),</span><br><span class="line">                &quot;product_code&quot;: &quot;FAST_INSTANT_TRADE_PAY&quot;,</span><br><span class="line">            &#125;,</span><br><span class="line">            return_url&#x3D;settings.ALIPAY_RETURN_URL,</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        # 响应登录支付宝连接</span><br><span class="line">        # 真实环境电脑网站支付网关：https:&#x2F;&#x2F;openapi.alipay.com&#x2F;gateway.do? + order_string</span><br><span class="line">        # 沙箱环境电脑网站支付网关：https:&#x2F;&#x2F;openapi.alipaydev.com&#x2F;gateway.do? + order_string</span><br><span class="line">        alipay_url &#x3D; settings.ALIPAY_URL + &quot;?&quot; + order_string</span><br><span class="line">        # print(&quot;alipay_url&quot;)</span><br><span class="line">        # print(alipay_url)</span><br><span class="line">        return JsonResponse(&#123;&#39;code&#39;: 0, &#39;errmsg&#39;: &#39;OK&#39;, &#39;alipay_url&#39;: alipay_url&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="后台部署"><a href="#后台部署" class="headerlink" title="后台部署"></a>后台部署</h3><h4 id="弃用Django自带的admin，使用扩展-xadmin"><a href="#弃用Django自带的admin，使用扩展-xadmin" class="headerlink" title="弃用Django自带的admin，使用扩展 xadmin"></a>弃用Django自带的admin，使用扩展 xadmin</h4><h5 id="安装-ubuntu18-04-pip-install-https-github-com-sshwsfc-xadmin-tarball"><a href="#安装-ubuntu18-04-pip-install-https-github-com-sshwsfc-xadmin-tarball" class="headerlink" title="安装  ubuntu18.04  pip install https://github.com/sshwsfc/xadmin/tarball/ "></a>安装  ubuntu18.04  <code>pip install https://github.com/sshwsfc/xadmin/tarball/ </code></h5><p>​        win10  解决  <a href="https://blog.csdn.net/teavamc/article/details/75400755">https://blog.csdn.net/teavamc/article/details/75400755</a></p>
<h5 id="注册应用"><a href="#注册应用" class="headerlink" title="注册应用"></a>注册应用</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># xadmin  配置</span><br><span class="line">    &#39;xadmin&#39;,</span><br><span class="line">    &#39;crispy_forms&#39;,</span><br><span class="line">    &#39;reversion&#39;,</span><br></pre></td></tr></table></figure>

<h5 id="迁移Xadmin数据库"><a href="#迁移Xadmin数据库" class="headerlink" title="迁移Xadmin数据库"></a>迁移Xadmin数据库</h5><p> python manage.py makemigrations </p>
<h4 id="mysql-数据库主从"><a href="#mysql-数据库主从" class="headerlink" title="mysql 数据库主从"></a>mysql 数据库主从</h4><p><strong>作用</strong></p>
<ul>
<li><p>通过增加从服务器来提⾼数据库的性能，在主服务器上执⾏写⼊和更新，在从服务器器上向外提供读功能，可以动态地调整从服务器器的数量，从⽽调整整个数据库的性能。</p>
</li>
<li><p>提⾼数据安全，因为数据已复制到从服务器，从服务器可以终止复制进程，所以，可以在从服务器上备份⽽不破坏主服务器相应数据</p>
</li>
<li><p>在主服务器上生成实时数据，而在从服务器器上分析这些数据，从而提高主服务器的性能 </p>
</li>
</ul>
<h5 id="热备份-主机不停机，实时将数据备份给从机"><a href="#热备份-主机不停机，实时将数据备份给从机" class="headerlink" title="热备份 主机不停机，实时将数据备份给从机"></a>热备份 主机不停机，实时将数据备份给从机</h5><h5 id="冷备份-主机需要停机，再将数据备份给从机"><a href="#冷备份-主机需要停机，再将数据备份给从机" class="headerlink" title="冷备份   主机需要停机，再将数据备份给从机"></a>冷备份   主机需要停机，再将数据备份给从机</h5><p><strong>同步机制</strong></p>
<p>1.先执行冷备份</p>
<p>2.再执行热备份</p>
<p>![1623760067968](Django-knowledge point.assets/1623760067968.png)</p>
<p><strong>注意： mysql 主从机的版本，不要相差太大</strong></p>
<ol>
<li><p><strong>修改从机配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改端口</span><br><span class="line">port &#x3D; 8306</span><br><span class="line"></span><br><span class="line">#  是否生成日志文件   0 不生成  1生成</span><br><span class="line">general_log_file   &#x3D;  &#x2F;var&#x2F;log&#x2F;mysql&#x2F;mysql.log</span><br><span class="line">general_log        &#x3D;  0   </span><br><span class="line"></span><br><span class="line"># 主机 为1</span><br><span class="line"># 修改从机</span><br><span class="line">server-id    &#x3D; 2</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主机配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-id &#x3D; 1</span><br><span class="line"># log日志文件</span><br><span class="line">log_bin   &#x3D; &#x2F;var&#x2F;log&#x2F;mysql&#x2F;mysql-bin.log</span><br></pre></td></tr></table></figure>

<p><strong>重启主机的mysql</strong></p>
</li>
<li><p>![1623849155977](Django-knowledge point.assets/1623849155977.png)</p>
</li>
<li><p>创建从机账号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql –uroot –pmysql</span><br><span class="line">GRANT REPLICATION SLAVE ON *.* TO &#39;slave&#39;@&#39;%&#39; identified by &#39;slave&#39;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取mysql主机的二进制日志信息</p>
<p> 在主机上 <code>SHOW MASTER STATUS;</code></p>
<p> ![1623849799894](Django-knowledge point.assets/1623849799894.png)</p>
<p><strong>说明</strong></p>
<p>file  &gt;&gt;   从机热备份时读取数据的文件</p>
<p>Position   &gt;&gt;   从机热备份时读取数据的位置，节点</p>
<p>![1623854721035](Django-knowledge point.assets/1623854721035.png)</p>
<p>在从机上 <code>SHOW MASTER STATUS;</code></p>
<p>![1623854396821](Django-knowledge point.assets/1623854396821.png)</p>
</li>
</ol>
<h4 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h4><h5 id="1-安装"><a href="#1-安装" class="headerlink" title="1.  安装"></a>1.  安装</h5><ol>
<li><pre><code>pip install djangorestframework
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">##### 2. 注册序列化器</span><br><span class="line"></span><br><span class="line">   1. &#96;&#96;&#96;</span><br><span class="line">      INSTALLED_APPS &#x3D; [</span><br><span class="line">          ...</span><br><span class="line">          &#39;rest_framework&#39;,</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h5 id="3-创建序列化器"><a href="#3-创建序列化器" class="headerlink" title="3. 创建序列化器"></a>3. 创建序列化器</h5><ol>
<li><p>模型类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from django.db import models</span><br><span class="line"></span><br><span class="line"># Create your models here.</span><br><span class="line"># 准备书籍列表信息的模型类</span><br><span class="line">class BookInfo(models.Model):</span><br><span class="line">    # 创建字段，字段类型...</span><br><span class="line">    name &#x3D; models.CharField(max_length&#x3D;20, verbose_name&#x3D;&#39;名称&#39;)</span><br><span class="line">    pub_date &#x3D; models.DateField(verbose_name&#x3D;&#39;发布日期&#39;,null&#x3D;True)</span><br><span class="line">    breadcount &#x3D; models.IntegerField(default&#x3D;0, verbose_name&#x3D;&#39;阅读量&#39;)</span><br><span class="line">    bcommentcount &#x3D; models.IntegerField(default&#x3D;0, verbose_name&#x3D;&#39;评论量&#39;)</span><br><span class="line">    is_delete &#x3D; models.BooleanField(default&#x3D;False, verbose_name&#x3D;&#39;逻辑删除&#39;)</span><br><span class="line">    image &#x3D; models.ImageField(upload_to&#x3D;&#39;book&#39;, null&#x3D;True, verbose_name&#x3D;&#39;图片&#39;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table &#x3D; &#39;bookinfo&#39;  # 指明数据库表名</span><br><span class="line">        verbose_name &#x3D; &#39;图书&#39;  # 在admin站点中显示的名称</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        &quot;&quot;&quot;定义每个数据对象的显示信息&quot;&quot;&quot;</span><br><span class="line">        return self.name</span><br><span class="line"></span><br><span class="line"># 准备人物列表信息的模型类</span><br><span class="line">class HeroInfo(models.Model):</span><br><span class="line"></span><br><span class="line">    hname &#x3D; models.CharField(max_length&#x3D;20, verbose_name&#x3D;&#39;名称&#39;)</span><br><span class="line">    hgender &#x3D; models.IntegerField(max_length&#x3D;20,verbose_name&#x3D;&#39;密码&#39;)</span><br><span class="line">    hdesc &#x3D; models.CharField(max_length&#x3D;200, null&#x3D;True, verbose_name&#x3D;&#39;描述信息&#39;)</span><br><span class="line">    hbook &#x3D; models.ForeignKey(BookInfo,related_name&#x3D;&#39;people&#39;, on_delete&#x3D;models.CASCADE, verbose_name&#x3D;&#39;图书&#39;)  # 外键</span><br><span class="line">    is_delete &#x3D; models.BooleanField(default&#x3D;False, verbose_name&#x3D;&#39;逻辑删除&#39;)</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        db_table &#x3D; &#39;heroinfo&#39;</span><br><span class="line">        verbose_name &#x3D; &#39;人物信息&#39;</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        return self.hname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建<code>serializers.py</code>文件</p>
<ol>
<li>写序列化器</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from rest_framework import serializers</span><br><span class="line"></span><br><span class="line">from book.models import BookInfo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PeopleInfoSerializer(serializers.Serializer):</span><br><span class="line">    &quot;&quot;&quot;英雄数据序列化器&quot;&quot;&quot;</span><br><span class="line">    id &#x3D; serializers.IntegerField(label&#x3D;&#39;ID&#39;)</span><br><span class="line">    hname &#x3D; serializers.CharField(label&#x3D;&#39;名字&#39;)</span><br><span class="line">    hgender &#x3D; serializers.IntegerField(label&#x3D;&quot;性别&quot;)</span><br><span class="line">    hdesc &#x3D; serializers.CharField(label&#x3D;&quot;描述信息&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;定义序列化器&quot;&quot;&quot;</span><br><span class="line">class BookInfoSerializer(serializers.Serializer):</span><br><span class="line">    &quot;&quot;&quot;图书数据序列化器&quot;&quot;&quot;</span><br><span class="line">    id &#x3D; serializers.IntegerField(label&#x3D;&#39;ID&#39;)</span><br><span class="line">    name &#x3D; serializers.CharField(label&#x3D;&#39;名称&#39;)</span><br><span class="line">    pub_date &#x3D; serializers.DateField(label&#x3D;&#39;发布日期&#39;)</span><br><span class="line">    breadcount &#x3D; serializers.IntegerField(label&#x3D;&#39;阅读量&#39;)</span><br><span class="line">    bcommentcount &#x3D; serializers.IntegerField(label&#x3D;&#39;评论量&#39;)</span><br><span class="line">    #  一对多的序列化器</span><br><span class="line">    people &#x3D; PeopleInfoSerializer(many&#x3D;True)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class PeopleSerializer(serializers.Serializer):</span><br><span class="line">    &quot;&quot;&quot;英雄数据序列化器&quot;&quot;&quot;</span><br><span class="line">    id &#x3D; serializers.IntegerField(label&#x3D;&#39;ID&#39;)</span><br><span class="line">    hname &#x3D; serializers.CharField(label&#x3D;&#39;名字&#39;)</span><br><span class="line">    hgender &#x3D; serializers.IntegerField(label&#x3D;&quot;性别&quot;)</span><br><span class="line">    hdesc &#x3D; serializers.CharField(label&#x3D;&quot;描述信息&quot;)</span><br><span class="line"></span><br><span class="line">    # hbook_id &#x3D; serializers.IntegerField(label&#x3D;&quot;图书id&quot;)</span><br><span class="line">    # hbook &#x3D; serializers.PrimaryKeyRelatedField(label&#x3D;&#39;图书&#39;,read_only&#x3D;True)   # 不能被反序列化</span><br><span class="line">    # hbook &#x3D; serializers.PrimaryKeyRelatedField(label&#x3D;&#39;图书&#39;,queryset&#x3D;BookInfo.objects.all())</span><br><span class="line">    # # 此字段将被序列化为关联对象的字符串表示方式（即__str__方法的返回值）</span><br><span class="line">    # hbook &#x3D; serializers.StringRelatedField(label&#x3D;&quot;图书&quot;)</span><br><span class="line">    # # 图书的序列化信息</span><br><span class="line">    hbook &#x3D; BookInfoSerializer()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>序列化输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from book.models import BookInfo,HeroInfo</span><br><span class="line">hero &#x3D; HeroInfo.objects.get(id&#x3D;3)</span><br><span class="line">from book.serializers import PeopleSerializer</span><br><span class="line">hero_ser &#x3D; PeopleSerializer(hero)</span><br><span class="line">hero_ser.data</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>反序列化器</p>
<ol>
<li><p>写一个 字典</p>
</li>
<li><p>创建 序列化器对象 serializer </p>
</li>
<li><p>验证</p>
</li>
<li><p>保存</p>
<p><strong>代码</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> book.models <span class="keyword">import</span> BookInfo,HeroInfo</span><br><span class="line"><span class="keyword">from</span> book.serializers <span class="keyword">import</span> PeopleSerializer, BookInfoSerializer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">     <span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Python高级&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;pub_date&#x27;</span>:<span class="string">&#x27;2020-1-1&#x27;</span>,</span><br><span class="line">     <span class="string">&#x27;breadcount&#x27;</span>:<span class="number">100</span>,</span><br><span class="line">     <span class="string">&#x27;bcommentcount&#x27;</span>:<span class="number">200</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建序列化对象</span></span><br><span class="line">book = BookInfoSerializer(data=data)</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 验证 返回 True False</span></span><br><span class="line">book.is_valid()   </span><br><span class="line">   </span><br><span class="line"><span class="comment"># 查看报错信息</span></span><br><span class="line">book.errors</span><br><span class="line"><span class="comment"># 返回 &#123;&#125;  </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> <code>is_valid()</code> 方法还可以在验证失败时抛出异常serializers.ValidationError，可以通过传递<strong>raise_exception=True</strong>参数开启，REST framework接收到此异常，会向前端返回HTTP 400 Bad Request响应。  </p>
</li>
</ol>
</li>
</ol>
<p>![1623897517610](Django-knowledge point.assets/1623897517610.png)</p>
<p>   <strong>read__only和write__only 不能同时出现</strong></p>
<p>   **验证字段方法validate_filedname **</p>
<p>   可以  进行正则判断，</p>
<p>   ![1623898018991](Django-knowledge point.assets/1623898018991.png)</p>
<p>   <strong>validate</strong></p>
<p>   在序列化器中需要同时对多个字段进行比较验证时，可以定义validate方法来验证，如</p>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validate</span>(<span class="params">self, attrs</span>):</span></span><br><span class="line">       readcount = attrs[<span class="string">&#x27;readcount&#x27;</span>]</span><br><span class="line">       commentcount = attrs[<span class="string">&#x27;commentcount&#x27;</span>]</span><br><span class="line">       <span class="keyword">if</span> commentcount &gt; readcount:</span><br><span class="line">           <span class="keyword">raise</span> serializers.ValidationError(<span class="string">&#x27;评论量不能大于阅读量&#x27;</span>)</span><br><span class="line">       <span class="keyword">return</span> attrs</span><br></pre></td></tr></table></figure>

<p>   <strong>保存</strong></p>
<p>保存到数据库，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 序列化器类，定义create 方法</span><br><span class="line">def create(self, validated_data):</span><br><span class="line">        &quot;&quot;&quot;新建&quot;&quot;&quot;</span><br><span class="line">        return BookInfo.objects.create(**validated_data)</span><br></pre></td></tr></table></figure>

<p>代码</p>
<p>**注意： 如果创建序列化器对象的时候，没有传递instance实例，则调用save()方法的时候，create()被调用。 **</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from book.serializers import BookInfoSerializer</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; data &#x3D; &#123;</span><br><span class="line">...     &#39;name&#39;:&#39;Python高级&#39;,</span><br><span class="line">...     &#39;pub_date&#39;:&#39;2020-01-01&#39;,</span><br><span class="line">...     &#39;readcount&#39;:100,</span><br><span class="line">...     &#39;commentcount&#39;:20</span><br><span class="line">... &#125;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; serializer &#x3D; BookInfoSerializer(data&#x3D;data)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; serializer.is_valid(raise_exception&#x3D;True)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; serializer.save()</span><br><span class="line">&lt;BookInfo: Python高级&gt;</span><br></pre></td></tr></table></figure>

<p><strong>更新</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def update(self, instance, validated_data):</span><br><span class="line">        &quot;&quot;&quot;更新，instance为要更新的对象实例&quot;&quot;&quot;</span><br><span class="line">        instance.name &#x3D; validated_data.get(&#39;name&#39;, instance.name)</span><br><span class="line">        instance.pub_date &#x3D; validated_data.get(&#39;pub_date&#39;, instance.pub_date)</span><br><span class="line">        instance.readcount &#x3D; validated_data.get(&#39;readcount&#39;, instance.readcount)</span><br><span class="line">        instance.commentcount &#x3D; validated_data.get(&#39;commentcount&#39;, instance.commentcount)</span><br><span class="line">        instance.save()</span><br><span class="line">        return instance</span><br></pre></td></tr></table></figure>

<pre><code>  **注意： 如果创建序列化器对象的时候，如果传递了instance实例，则调用save()方法的时候，update()被调用。**</code></pre>
<p><strong>测试</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; from book.serializers import BookInfoSerializer</span><br><span class="line">&gt;&gt;&gt; from book.models import BookInfo</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; book &#x3D; BookInfo.objects.get(id&#x3D;5)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; data &#x3D; &#123;</span><br><span class="line">...     &#39;name&#39;:&#39;Django高级&#39;,</span><br><span class="line">...     &#39;pub_date&#39;:&#39;2020-01-01&#39;,</span><br><span class="line">...     &#39;readcount&#39;:100,</span><br><span class="line">...     &#39;commentcount&#39;:20</span><br><span class="line">... &#125;</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; serializer &#x3D; BookInfoSerializer(instance&#x3D;book,data&#x3D;data)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; serializer.is_valid(raise_exception&#x3D;True)</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; serializer.save()</span><br><span class="line">&lt;BookInfo: Django高级&gt;</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><strong>小结</strong></p>
<ul>
<li>如果没有传入<code>instance</code> 则 是保存 到数据库，自动调用 <code>create方法</code></li>
<li>传入<code>instance</code> 则 是更新 到数据库，自动调用 <code>update方法</code></li>
</ul>
<h4 id="两点说明："><a href="#两点说明：" class="headerlink" title="两点说明："></a>两点说明：</h4><p>1） 在对序列化器进行save()保存时，可以额外传递数据，这些数据可以在create()和update()中的validated_data参数获取到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serializer.save(user&#x3D;request.user)</span><br></pre></td></tr></table></figure>

<p>2）默认序列化器必须传递所有required的字段，否则会抛出验证异常。但是我们可以使用partial参数来允许部分字段更新</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">serializer &#x3D; BookInfoSerializer(instance&#x3D;book, data&#x3D;&#123;&#39;pub_date&#39;: &#39;2999-1-1&#39;&#125;, partial&#x3D;True)</span><br></pre></td></tr></table></figure>

<h4 id="模型类序列化器ModelSerializer"><a href="#模型类序列化器ModelSerializer" class="headerlink" title="模型类序列化器ModelSerializer"></a>模型类序列化器ModelSerializer</h4><h5 id="ModelSerializer与常规的Serializer相同，但提供了："><a href="#ModelSerializer与常规的Serializer相同，但提供了：" class="headerlink" title="ModelSerializer与常规的Serializer相同，但提供了："></a>ModelSerializer与常规的Serializer相同，但提供了：</h5><ul>
<li>基于模型类自动生成一系列字段</li>
<li>包含默认的create()和update()的实现</li>
</ul>
<h5 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from rest_framework import serializers</span><br><span class="line">from book.models import BookInfo</span><br><span class="line"></span><br><span class="line">class BookInfoModelSerializer(serializers.ModelSerializer):</span><br><span class="line"></span><br><span class="line">    class Meta:</span><br><span class="line">        model &#x3D; BookInfo   # 必须指定模型类</span><br><span class="line">        fields &#x3D; &#39;__all__&#39;	# 默认生成字段 </span><br><span class="line">        # 可以自己指定字段</span><br><span class="line">        # fields &#x3D; [&quot;id&quot;, &quot;name&quot;]</span><br><span class="line">        # 除去列表中的字段</span><br><span class="line">        # exclude &#x3D; [&quot;is_delete&quot;]</span><br></pre></td></tr></table></figure>

<h5 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h5><p>![1623999276975](Django-knowledge point.assets/1623999276975.png)</p>
<ul>
<li><p>设置某些字段为只读</p>
<p>![1624000128281](Django-knowledge point.assets/1624000128281.png)</p>
</li>
<li><p>额外参数</p>
<p>![1624000331193](Django-knowledge point.assets/1624000331193.png)</p>
</li>
</ul>
<h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><ul>
<li><p>扩展 Request</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Django自带的  request.GET </span><br><span class="line"># 扩展          request.query_params</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"># Django自带的  request.POST </span><br><span class="line"># 扩展          request.data</span><br></pre></td></tr></table></figure>
</li>
<li><p>扩展 Response</p>
<p> REST framework提供了<code>Renderer</code>渲染器，<strong>用来根据请求头中的</strong><code>Accept</code><strong>（接收数据类型声明）来自动转换响应数据到对应格式</strong>。如果前<strong>端请求中未进行Accept声明，则会采用默认方式处理响应数据</strong>，我们可以通过配置来修改默认响应格式。 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">REST_FRAMEWORK &#x3D; &#123;</span><br><span class="line">    &#39;DEFAULT_RENDERER_CLASSES&#39;: (  # 默认响应渲染类</span><br><span class="line">        &#39;rest_framework.renderers.JSONRenderer&#39;,  # json渲染器</span><br><span class="line">        &#39;rest_framework.renderers.BrowsableAPIRenderer&#39;,  # 浏览API渲染器</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>构造方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Response(data, status&#x3D;None, template_name&#x3D;None, headers&#x3D;None, content_type&#x3D;None)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>data</code>: 为响应准备的序列化处理后的数据；</li>
<li><code>status</code>: 状态码，默认200；</li>
<li><code>template_name</code>: 模板名称，如果使用<code>HTMLRenderer</code>时需指明；</li>
<li><code>headers</code>: 用于存放响应头信息的字典；</li>
<li><code>content_type</code>: 响应数据的Content-Type，通常此参数无需传递，REST framework会根据前端所需类型数据来设置该参数。</li>
</ul>
</li>
</ul>
<h5 id="1-APIView-一级"><a href="#1-APIView-一级" class="headerlink" title="1. APIView(一级)"></a>1. APIView(一级)</h5><p><code>APIView</code>与<code>View</code>的不同之处在于：</p>
<ul>
<li>传入到视图方法中的是REST framework的<code>Request</code>对象，而不是Django的<code>HttpRequeset</code>对象；</li>
<li>视图方法可以返回REST framework的<code>Response</code>对象，视图会为响应数据设置（render）符合前端要求的格式；</li>
<li>任何<code>APIException</code>异常都会被捕获到，并且处理成合适的响应信息；</li>
<li>在进行dispatch()分发前，会对请求进行身份认证、权限检查、流量控制。</li>
</ul>
<h5 id="支持定义的属性："><a href="#支持定义的属性：" class="headerlink" title="支持定义的属性："></a>支持定义的属性：</h5><ul>
<li><strong>authentication_classes</strong>列表或元祖，身份认证类</li>
<li><strong>permissoin_classes</strong>列表或元祖，权限检查类</li>
<li><strong>throttle_classes</strong>列表或元祖，流量控制类</li>
</ul>
<p>![1624234856277](Django-knowledge point.assets/1624234856277.png)</p>
<h5 id="2-GenericAPIView-二级"><a href="#2-GenericAPIView-二级" class="headerlink" title="2. GenericAPIView(二级)"></a>2. GenericAPIView(二级)</h5><h5 id="支持定义的属性：-1"><a href="#支持定义的属性：-1" class="headerlink" title="支持定义的属性："></a>支持定义的属性：</h5><ul>
<li><h3 id="列表视图与详情视图通用："><a href="#列表视图与详情视图通用：" class="headerlink" title="列表视图与详情视图通用："></a>列表视图与详情视图通用：</h3><ul>
<li><strong>queryset</strong>列表视图的查询集</li>
<li><strong>serializer_class</strong>视图使用的序列化器</li>
</ul>
</li>
<li><h3 id="详情页视图使用："><a href="#详情页视图使用：" class="headerlink" title="详情页视图使用："></a>详情页视图使用：</h3><ul>
<li><strong>lookup_field</strong>查询单一数据库对象时使用的条件字段，默认为’<code>pk</code>‘</li>
<li><strong>lookup_url_kwarg</strong>查询单一数据时URL中的参数关键字名称，默认与<strong>look_field</strong>相同</li>
</ul>
</li>
</ul>
<h5 id="3-Mixin"><a href="#3-Mixin" class="headerlink" title="3. Mixin"></a>3. Mixin</h5><h5 id="4-子类视图"><a href="#4-子类视图" class="headerlink" title="4. 子类视图"></a>4. 子类视图</h5>]]></content>
      <categories>
        <category>Django</category>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>商业模式</tag>
      </tags>
  </entry>
</search>
